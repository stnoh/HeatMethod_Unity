<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSparse.Interop</name>
    </assembly>
    <members>
        <member name="T:CSparse.Complex.Factorization.Cholmod">
            <summary>
            CHOLMOD wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.Cholmod.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the Cholmod class.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.Cholmod.Solve(System.Numerics.Complex[],System.Numerics.Complex[])">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Factorization.CudaCholesky.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Numerics.Complex})">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Factorization.CudaCholesky"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
        </member>
        <member name="M:CSparse.Complex.Factorization.CudaCholesky.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Numerics.Complex},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Factorization.CudaCholesky"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
            <param name="transpose">A value indicating, whether the storage should be transposed.</param>
        </member>
        <member name="M:CSparse.Complex.Factorization.CudaQR.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Numerics.Complex})">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Factorization.CudaQR"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
        </member>
        <member name="M:CSparse.Complex.Factorization.CudaQR.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Numerics.Complex},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Factorization.CudaQR"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
            <param name="transpose">A value indicating, whether the storage should be transposed.</param>
        </member>
        <member name="T:CSparse.Complex.Factorization.Pardiso">
            <summary>
            PARDISO wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.Pardiso.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the Pardiso class.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.Pardiso.#ctor(CSparse.Complex.SparseMatrix,System.Int32)">
            <summary>
            Initializes a new instance of the Pardiso class.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.Pardiso.Solve(System.Int32,System.Numerics.Complex[],System.Numerics.Complex[])">
            <inheritdoc />
        </member>
        <member name="T:CSparse.Complex.Factorization.SPQR">
            <summary>
            SPQR wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.SPQR.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the Cholmod class.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.SPQR.Solve(System.Numerics.Complex[],System.Numerics.Complex[])">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Factorization.SuperLU.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the SuperLU class.
            </summary>
        </member>
        <member name="T:CSparse.Complex.Factorization.Umfpack">
            <summary>
            UMFPACK wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Factorization.Umfpack.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the Umfpack class.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.Arpack"/> class for the standard eigenvalue problem.
            </summary>
            <param name="A">Complex matrix.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.#ctor(CSparse.Complex.SparseMatrix,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.Arpack"/> class for the standard eigenvalue problem.
            </summary>
            <param name="A">Complex matrix.</param>
            <param name="symmetric">Set to true, if the matrix A is Hermitian.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.#ctor(CSparse.Complex.SparseMatrix,CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.Arpack"/> class for the generalized eigenvalue problem.
            </summary>
            <param name="A">Complex matrix.</param>
            <param name="B">Complex matrix for generalized problem.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.#ctor(CSparse.Complex.SparseMatrix,CSparse.Complex.SparseMatrix,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.Arpack"/> class for the generalized eigenvalue problem.
            </summary>
            <param name="A">Complex matrix.</param>
            <param name="B">Complex matrix for generalized problem.</param>
            <param name="symmetric">Set to true, if the matrix A is Hermitian and B is Hermitian positive definite.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.SolveStandard(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.SolveStandard(System.Int32,System.Numerics.Complex,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem in shift-invert mode.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.SolveGeneralized(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Complex.Solver.Arpack.SolveGeneralized(System.Int32,System.Numerics.Complex,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem in user-defined shift-invert mode.
            </summary>
        </member>
        <member name="T:CSparse.Complex.Solver.ArpackResult">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.ArpackResult.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.ArpackResult"/> class.
            </summary>
            <param name="k">The number of eigenvalues requested.</param>
            <param name="size">The problem size.</param>
            <param name="computeEigenVectors">A value, indicating whether eigenvectors are requested.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.ArpackResult.EigenValuesReal">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.ArpackResult.EigenVectorsReal">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.ArpackResult.CreateEigenValuesArray">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.ArpackResult.CreateEigenVectorsMatrix">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.Feast.#ctor(CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.Feast"/> class for the standard Hermitian eigenvalue problem.
            </summary>
            <param name="A">Complex Hermitian matrix.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.Feast.#ctor(CSparse.Complex.SparseMatrix,CSparse.Complex.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Complex.Solver.Feast"/> class for the generalized Hermitian eigenvalue problem.
            </summary>
            <param name="A">Complex Hermitian matrix.</param>
            <param name="B">Complex Hermitian positive definite matrix for generalized problem.</param>
        </member>
        <member name="M:CSparse.Complex.Solver.Feast.SolveStandard(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.Feast.SolveStandard(System.Int32,System.Double,System.Double,CSparse.Storage.DenseColumnMajorStorage{System.Numerics.Complex})">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.Feast.SolveGeneralized(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.Feast.SolveGeneralized(System.Int32,System.Double,System.Double,CSparse.Storage.DenseColumnMajorStorage{System.Numerics.Complex})">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Complex.Solver.FeastResult.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Int32,System.Double[],CSparse.Storage.DenseColumnMajorStorage{System.Numerics.Complex},System.Double[])">
            <inheritdoc />
        </member>
        <member name="T:CSparse.Double.Factorization.Cholmod">
            <summary>
            CHOLMOD wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.Cholmod.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the Cholmod class.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.Cholmod.Solve(System.Double[],System.Double[])">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Factorization.CudaCholesky.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Factorization.CudaCholesky"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
        </member>
        <member name="M:CSparse.Double.Factorization.CudaCholesky.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Double},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Factorization.CudaCholesky"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
            <param name="transpose">A value indicating, whether the storage should be transposed.</param>
        </member>
        <member name="M:CSparse.Double.Factorization.CudaQR.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Factorization.CudaQR"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
        </member>
        <member name="M:CSparse.Double.Factorization.CudaQR.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{System.Double},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Factorization.CudaQR"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
            <param name="transpose">A value indicating, whether the storage should be transposed.</param>
        </member>
        <member name="T:CSparse.Double.Factorization.Pardiso">
            <summary>
            PARDISO wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.Pardiso.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the Pardiso class.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.Pardiso.#ctor(CSparse.Double.SparseMatrix,System.Int32)">
            <summary>
            Initializes a new instance of the Pardiso class.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.Pardiso.Solve(System.Int32,System.Double[],System.Double[])">
            <inheritdoc />
        </member>
        <member name="T:CSparse.Double.Factorization.SPQR">
            <summary>
            SPQR wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.SPQR.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the Cholmod class.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.SPQR.Solve(System.Double[],System.Double[])">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Factorization.SuperLU.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the SuperLU class.
            </summary>
        </member>
        <member name="T:CSparse.Double.Factorization.Umfpack">
            <summary>
            UMFPACK wrapper.
            </summary>
        </member>
        <member name="M:CSparse.Double.Factorization.Umfpack.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the Umfpack class.
            </summary>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.Arpack"/> class for the standard eigenvalue problem.
            </summary>
            <param name="A">Real matrix.</param>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.#ctor(CSparse.Double.SparseMatrix,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.Arpack"/> class for the standard eigenvalue problem.
            </summary>
            <param name="A">Real matrix.</param>
            <param name="symmetric">Set to true, if the matrix A is symmetric.</param>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.#ctor(CSparse.Double.SparseMatrix,CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.Arpack"/> class for the generalized eigenvalue problem.
            </summary>
            <param name="A">Real matrix.</param>
            <param name="B">Real matrix for generalized problem.</param>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.#ctor(CSparse.Double.SparseMatrix,CSparse.Double.SparseMatrix,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.Arpack"/> class for the generalized eigenvalue problem.
            </summary>
            <param name="A">Real matrix.</param>
            <param name="B">Real matrix for generalized problem.</param>
            <param name="symmetric">Set to true, if the matrix A is symmetric and B is symmetric positive definite.</param>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SolveStandard(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SolveStandard(System.Int32,System.Double,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem in shift-invert mode.
            </summary>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SolveGeneralized(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SolveGeneralized(System.Int32,System.Double,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem in user-defined shift-invert mode.
            </summary>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SolveGeneralized(System.Int32,System.Double,CSparse.Interop.ARPACK.ShiftMode,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem in user-defined shift-invert mode.
            </summary>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SolveGeneralized(System.Int32,System.Double,System.Double,System.Char,CSparse.Solvers.Spectrum)">
            <summary>
            Special case solving the standard real generalized eigenvalue problem with complex shift.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="sigma_r">The real part of the complex shift.</param>
            <param name="sigma_i">The imaginary part of the complex shift.</param>
            <param name="part">Part to apply ('R' for real, 'I' for imaginary).</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SingularValues(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Compute singular values and the partial singular value decomposition.
            </summary>
            <param name="k">The number of singular values to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged singular values.</returns>
        </member>
        <member name="M:CSparse.Double.Solver.Arpack.SingularValues(System.Int32,System.Boolean,CSparse.Solvers.Spectrum)">
            <summary>
            Compute singular values and the partial singular value decomposition.
            </summary>
            <param name="k">The number of singular values to compute.</param>
            <param name="normal">Use normal equation to compute (squared) singular values.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged singular values.</returns>
            <remarks>
            If <paramref name="normal"/> is true, the normal equation <c>(A'*A)*v = sigma*v</c>
            is considered, where A is an m-by-n real matrix. This formulation is appropriate
            when m >= n. The roles of A and A' must be reversed in the case that m &lt; n.
            
            The eigenvalues returned are the squared singular values of A. If requested, the
            returned eigenvectors correspond to the right singular vectors, if <c>A = U*S*V'</c>.
            The left singular vectors can be computed from the equation <c>A*v - sigma*u = 0</c>.
            
            If <paramref name="normal"/> is false, the symmetric system <c>[0  A; A' 0]</c> is
            considered (size m + n), where A is an m-by-n real matrix.
            
            This problem can be used to obtain the decomposition <c>A = U*S*V'</c>. The positive
            eigenvalues of this problem are the singular values of A (the eigenvalues come in
            pairs, the negative eigenvalues have the same magnitude of the positive ones and
            can be discarded). The columns of U can be extracted from the first m components
            of the eigenvectors y, while the columns of V can be extracted from the remaining
            n components.
            </remarks>
        </member>
        <member name="T:CSparse.Double.Solver.ArpackResult">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ArpackResult.#ctor(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.ArpackResult"/> class.
            </summary>
            <param name="k">The number of eigenvalues requested.</param>
            <param name="size">The problem size.</param>
            <param name="computeEigenVectors">A value, indicating whether eigenvectors are requested.</param>
            <param name="symmetric">A value, indicating whether problem is symmetric.</param>
        </member>
        <member name="M:CSparse.Double.Solver.ArpackResult.EigenValuesReal">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ArpackResult.EigenVectorsReal">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ArpackResult.CreateEigenValuesArray">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ArpackResult.CreateEigenVectorsMatrix">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolver.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the ExtendedEigensolver class.
            </summary>
            <param name="A">Real symmetric matrix.</param>
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolver.#ctor(CSparse.Double.SparseMatrix,CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the ExtendedEigensolver class.
            </summary>
            <param name="A">Real symmetric matrix.</param>
            <param name="B">Real symmetric positive definite matrix for generalized problem.</param>
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolver.SolveStandard(System.Int32,CSparse.Interop.MKL.Job)">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolver.SolveStandard(System.Int32,CSparse.Interop.MKL.Job,CSparse.Storage.DenseColumnMajorStorage{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolver.SolveGeneralized(System.Int32,CSparse.Interop.MKL.Job)">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolver.SolveGeneralized(System.Int32,CSparse.Interop.MKL.Job,CSparse.Storage.DenseColumnMajorStorage{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolverResult.#ctor(CSparse.Interop.MKL.SparseStatus,System.Int32,System.Int32,System.Double[],CSparse.Matrix{System.Double},System.Double[])">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolverResult.EigenValuesReal">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.ExtendedEigensolverResult.EigenVectorsReal">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.Feast.#ctor(CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.Feast"/> class.
            </summary>
            <param name="A">Real symmetric matrix.</param>
        </member>
        <member name="M:CSparse.Double.Solver.Feast.#ctor(CSparse.Double.SparseMatrix,CSparse.Double.SparseMatrix)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Double.Solver.Feast"/> class.
            </summary>
            <param name="A">Real symmetric matrix.</param>
            <param name="B">Real symmetric positive definite matrix for generalized problem.</param>
        </member>
        <member name="M:CSparse.Double.Solver.Feast.SolveStandard(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.Feast.SolveStandard(System.Int32,System.Double,System.Double,CSparse.Storage.DenseColumnMajorStorage{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.Feast.SolveGeneralized(System.Int32,System.Double,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.Feast.SolveGeneralized(System.Int32,System.Double,System.Double,CSparse.Storage.DenseColumnMajorStorage{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:CSparse.Double.Solver.FeastResult.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Int32,System.Double[],CSparse.Storage.DenseColumnMajorStorage{System.Double},System.Double[])">
            <inheritdoc />
        </member>
        <member name="T:CSparse.Interop.ARPACK.ArpackContext`1">
            <summary>
            ARPACK eigenvalue solver.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackContext`1.ArnoldiCount">
            <summary>
            Gets or sets the number of Arnoldi vectors used in each iteration.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackContext`1.Iterations">
            <summary>
            Gets or sets the maximum number of iterations.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackContext`1.Tolerance">
            <summary>
            Gets or sets the residual tolerance (if &lt;= 0, ARPACK will use machine epsilon).
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackContext`1.ComputeEigenVectors">
            <summary>
            Gets or sets a value indicating whether to compute eigenvectors.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0},System.Boolean)">
            <summary>
            Initialize the standard eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0},CSparse.Storage.CompressedColumnStorage{`0},System.Boolean)">
            <summary>
            Initialize the generalized eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackContext`1.SolveStandard(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackContext`1.SolveStandard(System.Int32,`0,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem in shift-invert mode.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="sigma">The shift value.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackContext`1.SolveGeneralized(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackContext`1.SolveGeneralized(System.Int32,`0,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem in shift-invert mode.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="sigma">The shift value.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>The number of converged eigenvalues.</returns>
        </member>
        <member name="T:CSparse.Interop.ARPACK.ArpackException">
            <summary>
            Arpack++ exception (see arerror.h header file).
            </summary>
        </member>
        <member name="T:CSparse.Interop.ARPACK.ArpackResult`1">
            <summary>
            ARPACK result.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackResult`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.ARPACK.ArpackResult`1"/> class.
            </summary>
            <param name="k">The number of eigenvalues requested.</param>
            <param name="size">The problem size.</param>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.Count">
            <summary>
            Gets the number of requested eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.ConvergedEigenValues">
            <summary>
            Gets the number of converged eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.IterationsTaken">
            <summary>
            Gets the number of iteration taken.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.ArnoldiCount">
            <summary>
            Gets the number of Arnoldi vectors computed.
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.ErrorCode">
            <summary>
            Gets the error code returned by ARPACK (0 = all fine).
            </summary>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.EigenVectors">
            <summary>
            Gets the dense matrix of eigenvectors stored in column major order.
            </summary>
            <remarks>
            For real symmetric matrices, eigenvectors will be real. Use EigenVectorsReal().
            </remarks>
        </member>
        <member name="P:CSparse.Interop.ARPACK.ArpackResult`1.EigenValues">
            <summary>
            Gets the eigenvalues.
            </summary>
            <remarks>
            For real symmetric matrices, eigenvalues will be real. Use EigenValuesReal().
            </remarks>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackResult`1.EnsureSuccess">
            <summary>
            Throws an <see cref="T:CSparse.Interop.ARPACK.ArpackException"/>, if ARPACK failed to solve the problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackResult`1.EigenValuesReal">
            <summary>
            Gets the real part of the eigenvalues.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackResult`1.EigenVectorsReal">
            <summary>
            Gets the real part of the eigenvectors.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackResult`1.CreateEigenValuesArray">
            <summary>
            Creates the array of eigenvalues.
            </summary>
        </member>
        <member name="M:CSparse.Interop.ARPACK.ArpackResult`1.CreateEigenVectorsMatrix">
            <summary>
            Creates the matrix of eigenvectors.
            </summary>
        </member>
        <member name="T:CSparse.Interop.ARPACK.ar_spmat">
            <summary>
            Sparse matrix in column compressed format.
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ar_spmat.m">
            <summary>
            number of rows
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ar_spmat.n">
            <summary>
            number of columns
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ar_spmat.x">
            <summary>
            array of nonzero values
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ar_spmat.i">
            <summary>
            array of column indices
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ar_spmat.p">
            <summary>
            array of row pointers
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ar_spmat.nnz">
            <summary>
            number of nonzeros in the matrix
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ShiftMode.None">
            <summary>
            No shift applied.
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ShiftMode.Regular">
            <summary>
            Regular shift-invert mode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ShiftMode.Buckling">
            <summary>
            Buckling mode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.ARPACK.ShiftMode.Cayley">
            <summary>
            Cayley mode.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodContext`1">
            <summary>
            CHOLMOD context wrapping native factorization.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.Version">
            <summary>
            Return the CHOLMOD version.
            </summary>
            <returns>The CHOLMOD version.</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Cholmod.CholmodContext`1"/> class.
            </summary>
            <param name="matrix">The sparse matrix to factorize.</param>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.Factorize">
            <summary>
            Factorizes the matrix associated to this CHOLMOD instance.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.Solve(`0[],`0[])">
            <summary>
            Solves a system of linear equations, Ax = b.
            </summary>
            <param name="input">Right hand side vector b.</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.Solve(CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solves multiple systems of linear equations, AX = B.
            </summary>
            <param name="input">Right hand side matrix B.</param>
            <param name="result">Solution matrix X.</param>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.DoFactorize">
            <summary>
            Do symbolic and numeric factorization.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.DoSolve(CSparse.Interop.Cholmod.CholmodSolve,CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve multiple systems of linear equations.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right hand side B</param>
            <param name="result">Solution matrix X.</param>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.CopyDense(CSparse.Interop.Cholmod.CholmodDense,CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Copy native memory to dense matrix.
            </summary>
            <param name="dense">CHOLMOD dense matrix.</param>
            <param name="matrix">Target storage.</param>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.CreateDense(CSparse.Storage.DenseColumnMajorStorage{`0},System.Collections.Generic.List{System.Runtime.InteropServices.GCHandle})">
            <summary>
            Create CHOLMOD dense matrix from managed type.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="handles">List of handles.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.CholmodContext`1.CreateSparse(CSparse.Storage.CompressedColumnStorage{`0},System.Collections.Generic.List{System.Runtime.InteropServices.GCHandle})">
            <summary>
            Create CHOLMOD sparse matrix from managed type.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="handles">List of handles.</param>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodDense">
            <summary>
            A dense matrix in column-oriented form.
            </summary>
            <remarks>
            Entry in row i and column j is located in x [i+j*d]
            </remarks>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.nrow">
            <summary>
            the matrix is nrow-by-ncol
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.ncol">
            <summary>
            the matrix is nrow-by-ncol
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.nzmax">
            <summary>
            maximum number of entries in the matrix
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.d">
            <summary>
            leading dimension (d >= nrow must hold)
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.x">
            <summary>
            size nzmax or 2*nzmax, if present
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.z">
            <summary>
            size nzmax, if present
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.xtype">
            <summary>
            pattern, real, complex, or zomplex
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodDense.dtype">
            <summary>
            x and z double or float
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodException">
            <summary>
            CHOLMOD exception.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Cholmod.CholmodException.ErrorCode">
            <summary>
            Zero means success, negative means a fatal error, positive is a warning.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodFactor">
             <summary>
             A symbolic and numeric factorization, either simplicial or supernodal.
             </summary>
             <remarks>
             There are 8 types of factor objects that cholmod_factor can represent
             (only 6 are used):
            
             Numeric types (xtype is not CHOLMOD_PATTERN)
             --------------------------------------------
            
             simplicial LDL':  (is_ll FALSE, is_super FALSE).  Stored in compressed
            	    column form, using the simplicial components above (nzmax, p, i,
            	    x, z, nz, next, and prev).  The unit diagonal of L is not stored,
            	    and D is stored in its place.  There are no supernodes.
            
             simplicial LL': (is_ll TRUE, is_super FALSE).  Uses the same storage
            	    scheme as the simplicial LDL', except that D does not appear.
            	    The first entry of each column of L is the diagonal entry of
            	    that column of L.
            
             supernodal LDL': (is_ll FALSE, is_super TRUE).  Not used.
            	    FUTURE WORK:  add support for supernodal LDL'
            
             supernodal LL': (is_ll TRUE, is_super TRUE).  A supernodal factor,
            	    using the supernodal components described above (nsuper, ssize,
            	    xsize, maxcsize, maxesize, super, pi, px, s, x, and z).
            
            
             Symbolic types (xtype is CHOLMOD_PATTERN)
             -----------------------------------------
            
             simplicial LDL': (is_ll FALSE, is_super FALSE).  Nothing is present
            	    except Perm and ColCount.
            
             simplicial LL': (is_ll TRUE, is_super FALSE).  Identical to the
            	    simplicial LDL', except for the is_ll flag.
            
             supernodal LDL': (is_ll FALSE, is_super TRUE).  Not used.
            	    FUTURE WORK:  add support for supernodal LDL'
            
             supernodal LL': (is_ll TRUE, is_super TRUE).  A supernodal symbolic
            	    factorization.  The simplicial symbolic information is present
            	    (Perm and ColCount), as is all of the supernodal factorization
            	    except for the numerical values (x and z).
             </remarks>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.n">
            <summary>
            L is n-by-n
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.minor">
            <summary>
            If the factorization failed, L->minor is the column at which it failed.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.Perm">
            <summary>
            size n, permutation used
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.ColCount">
            <summary>
            size n, column counts for simplicial L
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.IPerm">
            <summary>
            size n, inverse permutation.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.nzmax">
            <summary>
            size of i and x
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.p">
            <summary>
            p [0..ncol], the column pointers
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.i">
            <summary>
            i [0..nzmax-1], the row indices
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.x">
            <summary>
            x [0..nzmax-1], the numerical values
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.nz">
            <summary>
            nz [0..ncol-1], the # of nonzeros in each column.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.next">
            <summary>
            size ncol+2. next [j] is the next column in i/x
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.prev">
            <summary>
            size ncol+2. prev [j] is the prior column in i/x.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.nsuper">
            <summary>
            number of supernodes
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.ssize">
            <summary>
            size of s, integer part of supernodes
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.xsize">
            <summary>
            size of x, real part of supernodes
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.maxcsize">
            <summary>
            size of largest update matrix
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.maxesize">
            <summary>
            max # of rows in supernodes, excl. triangular part
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.super">
            <summary>
            size nsuper+1, first col in each supernode
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.pi">
            <summary>
            size nsuper+1, pointers to integer patterns
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.px">
            <summary>
            size nsuper+1, pointers to real parts
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.s">
            <summary>
            size ssize, integer part of supernodes
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.ordering">
            <summary>
            ordering method used
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.is_ll">
            <summary>
            TRUE if LL', FALSE if LDL'
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.is_super">
            <summary>
            TRUE if supernodal, FALSE if simplicial
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.is_monotonic">
            <summary>
            TRUE if columns of L appear in order 0..n-1.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.itype">
            <summary>
            integer type
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.xtype">
            <summary>
            pattern, real, complex, or zomplex
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.dtype">
            <summary>
            x and z double or float
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodFactor.useGPU">
            <summary>
            Indicates the symbolic factorization supports GPU acceleration
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodSparse">
            <summary>
            A sparse matrix stored in compressed-column form.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.nrow">
            <summary>
            the matrix is nrow-by-ncol
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.ncol">
            <summary>
            the matrix is nrow-by-ncol
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.nzmax">
            <summary>
            maximum number of entries in the matrix
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.p">
            <summary>
            p [0..ncol], the column pointers
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.i">
            <summary>
            i [0..nzmax-1], the row indices
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.nz">
            <summary>
            nz [0..ncol-1], the # of nonzeros in each col.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.x">
            <summary>
            size nzmax or 2*nzmax, if present
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.z">
            <summary>
            size nzmax, if present
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.stype">
            <summary>
            Describes what parts of the matrix are considered
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.itype">
            <summary>
            interger type
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.xtype">
            <summary>
            pattern, real, complex, or zomplex
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.dtype">
            <summary>
            x and z are double or float
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.sorted">
            <summary>
            TRUE if columns are sorted, FALSE otherwise
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSparse.packed">
            <summary>
            TRUE if packed (nz ignored), FALSE if unpacked (nz is required)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:CSparse.Interop.Cholmod.CholmodTriplet" -->
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.nrow">
            <summary>
            the matrix is nrow-by-ncol
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.ncol">
            <summary>
            the matrix is nrow-by-ncol
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.nzmax">
            <summary>
            maximum number of entries in the matrix
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.nnz">
            <summary>
            number of nonzeros in the matrix
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.i">
            <summary>
            i [0..nzmax-1], the row indices
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.j">
            <summary>
            j [0..nzmax-1], the column indices
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.x">
            <summary>
            size nzmax or 2*nzmax, if present
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.z">
            <summary>
            size nzmax, if present
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.stype">
            <summary>
            Describes what parts of the matrix are considered
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.itype">
            <summary>
            CHOLMOD_LONG: i and j are SuiteSparse_long.  Otherwise int
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.xtype">
            <summary>
            pattern, real, complex, or zomplex
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodTriplet.dtype">
            <summary>
            x and z are double or float
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.Dtype">
            <summary>
            Defines what the numerical type is (double or float)
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Dtype.Double">
            <summary>
            all numerical values are double
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Dtype.Single">
            <summary>
            all numerical values are float
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.Xtype">
             <summary>
             Defines the kind of numerical values used.
             </summary>
             <remarks>
             The xtype of all parameters for all CHOLMOD routines must match.
             
             CHOLMOD_PATTERN: x and z are ignored.
             CHOLMOD_DOUBLE:  x is non-null of size nzmax, z is ignored.
             CHOLMOD_COMPLEX: x is non-null of size 2* nzmax doubles, z is ignored.
             CHOLMOD_ZOMPLEX: x and z are non-null of size nzmax
            
             In the real case, z is ignored.The kth entry in the matrix is x[k].
             There are two methods for the complex case.  In the ANSI C99-compatible
             CHOLMOD_COMPLEX case, the real and imaginary parts of the kth entry
             are in x[2 /// k] and x[2 /// k + 1], respectively.z is ignored.In the
             MATLAB-compatible CHOLMOD_ZOMPLEX case, the real and imaginary
             parts of the kth entry are in x[k] and z[k].
            
             Scalar floating-point values are always passed as double arrays of size 2
             (real and imaginary parts).  The imaginary part of a scalar is ignored if
             the routine operates on a real matrix.
            
             These Modules support complex and zomplex matrices, with a few exceptions:
            
             Check       all routines
             Cholesky    all routines
             Core        all except cholmod_aat, add, band, copy
             Demo        all routines
             Partition   all routines
             Supernodal  all routines support any real, complex, or zomplex input.
             
             There will never be a supernodal zomplex L; a complex
             supernodal L is created if A is zomplex.
            
             These Modules do not support complex and zomplex matrices at all:
            
             Modify      all routines support real matrices only
             </remarks>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Xtype.Pattern">
            <summary>
            Pattern only, no numerical values.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Xtype.Real">
            <summary>
            A real matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Xtype.Complex">
            <summary>
            A complex matrix (ANSI C99 compatible).
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.Stype">
            <summary>
            Describes what parts of the matrix are considered.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Stype.Upper">
            <summary>
            Matrix is square and symmetric, use upper triangular part.
            Entries in the lower triangular part are ignored.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Stype.General">
            <summary>
            Matrix is "unsymmetric": use both upper and lower triangular parts
            (the matrix may actually be symmetric in pattern and value, but
            both parts are explicitly stored and used).  May be square or
            rectangular.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.Stype.Lower">
            <summary>
            Matrix is square and symmetric, use lower triangular part.
            Entries in the upper triangular part are ignored.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodSolve">
            <summary>
            Cholmod solve codes.
            </summary>
            <remarks>
            Solves one of many linear systems with a dense right-hand-side, using the
            factorization from cholmod_factorize (or as modified by any other CHOLMOD
            routine).  D is identity for LL' factorizations.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.A">
            <summary>
            solve Ax=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.LDLt">
            <summary>
            solve LDL'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.LD">
            <summary>
            solve LDx=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.DLt">
            <summary>
            solve DL'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.L">
            <summary>
            solve Lx=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.Lt">
            <summary>
            solve L'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.D">
            <summary>
            solve Dx=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.P">
            <summary>
            permute x=Px
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodSolve.Pt">
            <summary>
            permute x=P'x
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodScale">
            <summary>
            Scaling modes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodScale.Scalar">
            <summary>
            A = s*A
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodScale.Row">
            <summary>
            A = diag(s)*A.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodScale.Column">
            <summary>
            A = A*diag(s).
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodScale.Sym">
            <summary>
            A = diag(s)*A*diag(s).
            </summary>
        </member>
        <member name="T:CSparse.Interop.Cholmod.CholmodOrdering">
            <summary>
            Ordering method to use.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.Natural">
            <summary>
            Use natural ordering.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.Given">
            <summary>
            Use given permutation.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.AMD">
            <summary>
            Use minimum degree (AMD).
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.METIS">
            <summary>
            Use METIS' nested dissection.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.NESDIS">
            <summary>
            Use CHOLMOD's version of nested dissection.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.COLAMD">
            <summary>
            Use AMD for A, COLAMD for A*A'.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Cholmod.CholmodOrdering.PostOrdered">
            <summary>
            Natural ordering, postordered.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_init">
            <summary>
            Returns a pointer to a cholmod_common struct.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_start(CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            first call to CHOLMOD
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_finish(CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            last call to CHOLMOD
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_defaults(CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            restore default parameters
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_transpose(CSparse.Interop.Cholmod.CholmodSparse@,System.Int32,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            transpose a sparse matrix
            </summary>
            <param name="A">matrix to transpose</param>
            <param name="values">0: pattern, 1: array transpose, 2: conj. transpose</param>
            <param name="c"></param>
            <returns>Return A' or A.'  The "values" parameter is 0, 1, or 2 to denote the pattern
            transpose, the array transpose (A.'), and the complex conjugate transpose (A').</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_transpose_unsym(CSparse.Interop.Cholmod.CholmodSparse@,System.Int32,System.IntPtr,System.IntPtr,System.UInt64,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            transpose an unsymmetric sparse matrix
            </summary>
            <param name="A">matrix to transpose</param>
            <param name="values">0: pattern, 1: array transpose, 2: conj. transpose</param>
            <param name="Perm">size nrow, if present (can be NULL)</param>
            <param name="fset">subset of 0:(A->ncol)-1</param>
            <param name="fsize">size of fset</param>
            <param name="F">F = A', A(:,f)', or A(p,f)'</param>
            <param name="c"></param>
            <returns></returns>
            <remarks>
            Compute F = A', A (:,f)', or A (p,f)', where A is unsymmetric and F is
            already allocated.  See cholmod_transpose for a simpler routine.
            </remarks>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_transpose_sym(CSparse.Interop.Cholmod.CholmodSparse@,System.Int32,System.IntPtr,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            transpose a symmetric sparse matrix
            </summary>
            <param name="A">matrix to transpose</param>
            <param name="values">0: pattern, 1: array transpose, 2: conj. transpose</param>
            <param name="Perm">size nrow, if present (can be NULL)</param>
            <param name="F">F = A' or A(p,p)'</param>
            <param name="c"></param>
            <returns></returns>
            <remarks>
            Compute F = A' or A (p,p)', where A is symmetric and F is already allocated.
            See cholmod_transpose for a simpler routine.
            </remarks>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_add(CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodSparse@,System.Double[],System.Double[],System.Int32,System.Int32,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            C = alpha*A + beta*B
            </summary>
            <param name="A">matrix to add</param>
            <param name="B">matrix to add</param>
            <param name="alpha">scale factor for A</param>
            <param name="beta">scale factor for B</param>
            <param name="values">if TRUE compute the numerical values of C</param>
            <param name="sorted">if TRUE, sort columns of C</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_free_factor(System.IntPtr@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            free a factor
            </summary>
            <param name="L">factor to free, NULL on output</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_free_dense(System.IntPtr@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            free a dense matrix
            </summary>
            <param name="X">dense matrix to deallocate, NULL on output</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_version(System.Int32[])">
            <summary>
            
            </summary>
            <param name="version">output, contents not defined on input.  Not used if NULL.</param>
            <returns>returns CHOLMOD_VERSION</returns>
            <remarks>
               version [0] = CHOLMOD_MAIN_VERSION
               version [1] = CHOLMOD_SUB_VERSION
               version [2] = CHOLMOD_SUBSUB_VERSION
            </remarks>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_common(CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check the Common object
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_sparse(CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check a sparse matrix
            </summary>
            <param name="A">sparse matrix to check</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_dense(CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check a dense matrix
            </summary>
            <param name="X">dense matrix to check</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_factor(CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check a factor
            </summary>
            <param name="L">factor to check</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_triplet(CSparse.Interop.Cholmod.CholmodTriplet@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check a sparse matrix in triplet form
            </summary>
            <param name="T">triplet matrix to check</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_subset(System.IntPtr,System.Int64,System.UInt64,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check a subset
            </summary>
            <param name="Set">Set [0:len-1] is a subset of 0:n-1.  Duplicates OK</param>
            <param name="len">size of Set (an integer array)</param>
            <param name="n">0:n-1 is valid range</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_check_perm(System.IntPtr,System.UInt64,System.UInt64,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            check a permutation
            </summary>
            <param name="Perm">Perm [0:len-1] is a permutation of subset of 0:n-1</param>
            <param name="len">size of Perm (an integer array)</param>
            <param name="n">0:n-1 is valid range</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_analyze(CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            order and analyze (simplicial or supernodal)
            </summary>
            <param name="A">matrix to order and analyze</param>
            <param name="c"></param>
            <returns>cholmod_factor</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_analyze_p(CSparse.Interop.Cholmod.CholmodSparse@,System.IntPtr,System.IntPtr,System.UInt64,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            analyze, with user-provided permutation or f set
            </summary>
            <param name="A">matrix to order and analyze</param>
            <param name="UserPerm">user-provided permutation, size A->nrow</param>
            <param name="fset">subset of 0:(A->ncol)-1</param>
            <param name="fsize">size of fset</param>
            <param name="c"></param>
            <returns>cholmod_factor</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_analyze_p2(System.Int32,CSparse.Interop.Cholmod.CholmodSparse@,System.IntPtr,System.IntPtr,System.UInt64,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            analyze for sparse Cholesky or sparse QR
            </summary>
            <param name="for_whom">
            FOR_SPQR     (0): for SPQR but not GPU-accelerated
            FOR_CHOLESKY (1): for Cholesky (GPU or not)
            FOR_SPQRGPU  (2): for SPQR with GPU acceleration
            </param>
            <param name="A">matrix to order and analyze</param>
            <param name="UserPerm">user-provided permutation, size A->nrow</param>
            <param name="fset">subset of 0:(A->ncol)-1</param>
            <param name="fsize">size of fset</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_factorize(CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            simplicial or supernodal Cholesky factorization
            </summary>
            <param name="A">matrix to factorize</param>
            <param name="L">resulting factorization</param>
            <param name="c"></param>
            <returns>returns TRUE on success, FALSE on failure</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_factorize_p(CSparse.Interop.Cholmod.CholmodSparse@,System.Double[],System.IntPtr,System.UInt64,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            factorize, with user-provided permutation or fset
            </summary>
            <param name="A">matrix to factorize</param>
            <param name="beta">factorize beta*I+A or beta*I+A'*A  [size 2]</param>
            <param name="fset">subset of 0:(A->ncol)-1</param>
            <param name="fsize">size of fset</param>
            <param name="L">resulting factorization</param>
            <param name="c"></param>
            <returns>returns TRUE on success, FALSE on failure</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_solve(System.Int32,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            solve a linear system (simplicial or supernodal)
            </summary>
            <param name="sys">system to solve</param>
            <param name="L">factorization to use</param>
            <param name="B">right-hand-side</param>
            <param name="c"></param>
            <returns>returns the solution X</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_solve2(System.Int32,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodSparse@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            like cholmod_solve, but with reusable workspace
            </summary>
            <param name="sys">system to solve</param>
            <param name="L">factorization to use</param>
            <param name="B">right-hand-side</param>
            <param name="Bset">solution, allocated if need be</param>
            <param name="X_Handle">cholmod_sparse</param>
            <param name="Xset_Handle">cholmod_sparse</param>
            <param name="Y_Handle">workspace, or NULL (cholmod_dense)</param>
            <param name="E_Handle">workspace, or NULL (cholmod_dense)</param>
            <param name="c"></param>
            <returns>returns TRUE on success, FALSE on failure</returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_spsolve(System.Int32,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            solve a linear system with a sparse right-hand-side
            </summary>
            <param name="sys">system to solve</param>
            <param name="L">factorization to use</param>
            <param name="B">right-hand-side</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_updown(System.Int32,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            multiple rank update/downdate
            </summary>
            <param name="update">TRUE for update, FALSE for downdate</param>
            <param name="C">the incoming sparse update</param>
            <param name="L">factor to modify</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Cholmod.NativeMethods.cholmod_updown_solve(System.Int32,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodFactor@,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            update/downdate, and modify solution to Lx=b
            </summary>
            <param name="update">TRUE for update, FALSE for downdate</param>
            <param name="C">the incoming sparse update</param>
            <param name="L">factor to modify</param>
            <param name="X">solution to Lx=b (size n-by-1)</param>
            <param name="DeltaB">change in b, zero on output</param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Common.InteropHelper.Pin(System.Object,System.Collections.Generic.List{System.Runtime.InteropServices.GCHandle})">
            <summary>
            Pin given object and add handle to list.
            </summary>
            <param name="data">Object to pin.</param>
            <param name="handles">List of handles.</param>
            <returns>Address of pinned object.</returns>
        </member>
        <member name="M:CSparse.Interop.Common.InteropHelper.Free(System.Collections.Generic.List{System.Runtime.InteropServices.GCHandle})">
            <summary>
            Free all handles of given list.
            </summary>
            <param name="handles">List of handles.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.Cuda.Initialize">
            <summary>
            Initializes the CUDA device with maximum GFLOPS.
            </summary>
            <returns>The CUDA device id.</returns>
            <exception cref="T:CSparse.Interop.CUDA.CudaException">Will throw, if no device is found.</exception>
        </member>
        <member name="M:CSparse.Interop.CUDA.Cuda.GetDeviceAttribute(CSparse.Interop.CUDA.DeviceAttribute,System.Int32)">
            <summary>
            Returns the requested CUDA device attribute.
            </summary>
            <param name="attribute">The <see cref="T:CSparse.Interop.CUDA.DeviceAttribute"/>.</param>
            <param name="device">The device id.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.CUDA.CudaException.#ctor(CSparse.Interop.CUDA.CudaResult)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.CUDA.CudaException"/> class.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:CSparse.Interop.CUDA.CudaStream.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.CUDA.CudaStream"/> class.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.CUDA.NativeMethods.cudaStreamCreate(System.IntPtr@)" -->
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cudaStreamDestroy(System.IntPtr)">
            <summary>
            Destroys the stream specified by hStream.
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpCreate(System.IntPtr@)">
            <summary>
            This function initializes the cuSolverSP library and creates a handle on the cuSolver
            context. It must be called before any other cuSolverSP API function is invoked. It
            allocates hardware resources necessary for accessing the GPU.
            </summary>
            <param name="handle">the pointer to the handle to the cuSolverSP context.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpDestroy(System.IntPtr)">
            <summary>
            This function releases CPU-side resources used by the cuSolverSP library.
            </summary>
            <param name="handle">the handle to the cuSolverSP context.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpSetStream(System.IntPtr,System.IntPtr)">
            <summary>
            This function sets the stream to be used by the cuSolverSP library to execute its routines.
            </summary>
            <param name="handle">the handle to the cuSolverSP context.</param>
            <param name="streamId">the stream to be used by the library.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpGetStream(System.IntPtr,System.IntPtr@)">
            <summary>
            This function gets the stream to be used by the cuSolverSP library to execute its routines.
            </summary>
            <param name="handle">the handle to the cuSolverSP context.</param>
            <param name="streamId">the stream to be used by the library.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpXcsrsymrcmHost(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Symmetric reverse Cuthill McKee permutation. 
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpXcsrsymmdqHost(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Symmetric minimum degree algorithm by quotient graph.
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpXcsrsymamdHost(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Symmetric Approximate minimum degree algorithm by quotient graph.
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpXcsrmetisndHost(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Symmetric reordering nested dissection (METIS).
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpXcsrperm_bufferSizeHost(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@)">
            <summary>
            Calculate buffer size for P*A*Q^T.
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.NativeMethods.cusolverSpXcsrpermHost(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Apply permutation P*A*Q^T.
            </summary>
        </member>
        <member name="T:CSparse.Interop.CUDA.CuSolverContext`1">
            <summary>
            The CuSolver context represents a solver and the associated workspace in device memory.
            </summary>
            <remarks>
            The solver is based on the CUSOLVER low level interface.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.CUDA.CuSolverContext`1.FactorizationTime">
            <summary>
            Gets the factorization time (seconds).
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.CuSolverContext`1.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.CUDA.CuSolverContext`1"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
            <param name="transpose">A value indicating, whether the storage should be transposed.</param>
            <remarks>
            Matrix transposition is done on a storage level, meaning, for complex matrices, values will not be
            conjugated. This is necessary, because CUDA expects CSR storage, while CSparse uses CSC storage.
            
            The value of <paramref name="transpose"/> should be true for all matrix types, except real
            valued, symmetric matrices.
            </remarks>
        </member>
        <member name="M:CSparse.Interop.CUDA.CuSolverContext`1.Solve(`0[],`0[])">
            <summary>
            Solves a system of linear equations, Ax = b.
            </summary>
            <param name="input">Right hand side vector b.</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.CuSolverContext`1.Factorize">
            <summary>
            Factorize the sparse matrix associated to the solver instance.
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.CuSolverException.#ctor(CSparse.Interop.CUDA.SolverStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.CUDA.CuSolverException"/> class.
            </summary>
            <param name="status"></param>
        </member>
        <member name="T:CSparse.Interop.CUDA.CuSparseContext`1">
            <summary>
            The CuSparse context represents a sparse matrix in device memory (storage format CSR).
            </summary>
        </member>
        <member name="M:CSparse.Interop.CUDA.CuSparseContext`1.#ctor(CSparse.Interop.CUDA.CudaStream,CSparse.Storage.CompressedColumnStorage{`0},CSparse.Interop.CUDA.MatrixType,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.CUDA.CuSparseContext`1"/> class.
            </summary>
            <param name="stream">The <see cref="T:CSparse.Interop.CUDA.CudaStream"/>.</param>
            <param name="A">The sparse matrix.</param>
            <param name="type">The matrix type.</param>
            <param name="transpose">A value indicating, whether the storage should be transposed.</param>
        </member>
        <member name="M:CSparse.Interop.CUDA.CuSparseException.#ctor(CSparse.Interop.CUDA.SparseStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.CUDA.CuSparseException"/> class.
            </summary>
            <param name="status"></param>
        </member>
        <member name="T:CSparse.Interop.CUDA.ComputeMode">
            <summary>
            Compute mode that device is currently in.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.ComputeMode.Default">
            <summary>
            Default compute mode (Multiple threads can use cudaSetDevice() with this device)
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.ComputeMode.Exclusive">
            <summary>
            Compute-exclusive-thread mode (Only one thread in one process will be able to use cudaSetDevice() with this device)
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.ComputeMode.Prohibited">
            <summary>
            Compute-prohibited mode (No threads can use cudaSetDevice() with this device)
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.ComputeMode.ExclusiveProcess">
            <summary>
            Compute-exclusive-process mode (Many threads in one process will be able to use cudaSetDevice() with this device)
            </summary>
        </member>
        <member name="T:CSparse.Interop.CUDA.DeviceAttribute">
            <summary>
            Device properties
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxThreadsPerBlock">
            <summary>
            Maximum number of threads per block.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxBlockDimX">
            <summary>
            Maximum block dimension X.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxBlockDimY">
            <summary>
            Maximum block dimension Y.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxBlockDimZ">
            <summary>
            Maximum block dimension Z.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxGridDimX">
            <summary>
            Maximum grid dimension X.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxGridDimY">
            <summary>
            Maximum grid dimension Y.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxGridDimZ">
            <summary>
            Maximum grid dimension Z.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSharedMemoryPerBlock">
            <summary>
            Maximum shared memory available per block in bytes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.TotalConstantMemory">
            <summary>
            Memory available on device for __constant__ variables in a CUDA C kernel in bytes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.WarpSize">
            <summary>
            Warp size in threads.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxPitch">
            <summary>
            Maximum pitch in bytes allowed by memory copies.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxRegistersPerBlock">
            <summary>
            Maximum number of 32-bit registers available per block.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ClockRate">
            <summary>
            Peak clock frequency in kilohertz.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.TextureAlignment">
            <summary>
            Alignment requirement for textures.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.GpuOverlap">
            <summary>
            Device can possibly copy memory and execute a kernel concurrently.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MultiProcessorCount">
            <summary>
            Number of multiprocessors on device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.KernelExecTimeout">
            <summary>
            Specifies whether there is a run time limit on kernels.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.Integrated">
            <summary>
            Device is integrated with host memory.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.CanMapHostMemory">
            <summary>
            Device can map host memory into CUDA address space.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ComputeMode">
            <summary>
            Compute mode (See cudaComputeMode for details).
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture1DWidth">
            <summary>
            Maximum 1D texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DWidth">
            <summary>
            Maximum 2D texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DHeight">
            <summary>
            Maximum 2D texture height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture3DWidth">
            <summary>
            Maximum 3D texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture3DHeight">
            <summary>
            Maximum 3D texture height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture3DDepth">
            <summary>
            Maximum 3D texture depth.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DLayeredWidth">
            <summary>
            Maximum 2D layered texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DLayeredHeight">
            <summary>
            Maximum 2D layered texture height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DLayeredLayers">
            <summary>
            Maximum layers in a 2D layered texture.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.SurfaceAlignment">
            <summary>
            Alignment requirement for surfaces.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ConcurrentKernels">
            <summary>
            Device can possibly execute multiple kernels concurrently.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.EccEnabled">
            <summary>
            Device has ECC support enabled.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.PciBusId">
            <summary>
            PCI bus ID of the device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.PciDeviceId">
            <summary>
            PCI device ID of the device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.TccDriver">
            <summary>
            Device is using TCC driver model.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MemoryClockRate">
            <summary>
            Peak memory clock frequency in kilohertz.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.GlobalMemoryBusWidth">
            <summary>
            Global memory bus width in bits.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.L2CacheSize">
            <summary>
            Size of L2 cache in bytes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxThreadsPerMultiProcessor">
            <summary>
            Maximum resident threads per multiprocessor.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.AsyncEngineCount">
            <summary>
            Number of asynchronous engines.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.UnifiedAddressing">
            <summary>
            Device shares a unified address space with the host.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture1DLayeredWidth">
            <summary>
            Maximum 1D layered texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture1DLayeredLayers">
            <summary>
            Maximum layers in a 1D layered texture.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DGatherWidth">
            <summary>
            Maximum 2D texture width if cudaArrayTextureGather is set.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DGatherHeight">
            <summary>
            Maximum 2D texture height if cudaArrayTextureGather is set.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture3DWidthAlt">
            <summary>
            Alternate maximum 3D texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture3DHeightAlt">
            <summary>
            Alternate maximum 3D texture height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture3DDepthAlt">
            <summary>
            Alternate maximum 3D texture depth.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.PciDomainId">
            <summary>
            PCI domain ID of the device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.TexturePitchAlignment">
            <summary>
            Pitch alignment requirement for textures.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTextureCubemapWidth">
            <summary>
            Maximum cubemap texture width/height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTextureCubemapLayeredWidth">
            <summary>
            Maximum cubemap layered texture width/height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTextureCubemapLayeredLayers">
            <summary>
            Maximum layers in a cubemap layered texture.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface1DWidth">
            <summary>
            Maximum 1D surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface2DWidth">
            <summary>
            Maximum 2D surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface2DHeight">
            <summary>
            Maximum 2D surface height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface3DWidth">
            <summary>
            Maximum 3D surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface3DHeight">
            <summary>
            Maximum 3D surface height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface3DDepth">
            <summary>
            Maximum 3D surface depth.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface1DLayeredWidth">
            <summary>
            Maximum 1D layered surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface1DLayeredLayers">
            <summary>
            Maximum layers in a 1D layered surface.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface2DLayeredWidth">
            <summary>
            Maximum 2D layered surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface2DLayeredHeight">
            <summary>
            Maximum 2D layered surface height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurface2DLayeredLayers">
            <summary>
            Maximum layers in a 2D layered surface.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurfaceCubemapWidth">
            <summary>
            Maximum cubemap surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurfaceCubemapLayeredWidth">
            <summary>
            Maximum cubemap layered surface width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSurfaceCubemapLayeredLayers">
            <summary>
            Maximum layers in a cubemap layered surface.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture1DLinearWidth">
            <summary>
            Maximum 1D linear texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DLinearWidth">
            <summary>
            Maximum 2D linear texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DLinearHeight">
            <summary>
            Maximum 2D linear texture height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DLinearPitch">
            <summary>
            Maximum 2D linear texture pitch in bytes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DMipmappedWidth">
            <summary>
            Maximum mipmapped 2D texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture2DMipmappedHeight">
            <summary>
            Maximum mipmapped 2D texture height.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ComputeCapabilityMajor">
            <summary>
            Major compute capability version number.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ComputeCapabilityMinor">
            <summary>
            Minor compute capability version number.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxTexture1DMipmappedWidth">
            <summary>
            Maximum mipmapped 1D texture width.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.StreamPrioritiesSupported">
            <summary>
            Device supports stream priorities.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.GlobalL1CacheSupported">
            <summary>
            Device supports caching globals in L1.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.LocalL1CacheSupported">
            <summary>
            Device supports caching locals in L1.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSharedMemoryPerMultiprocessor">
            <summary>
            Maximum shared memory available per multiprocessor in bytes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxRegistersPerMultiprocessor">
            <summary>
            Maximum number of 32-bit registers available per multiprocessor.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ManagedMemory">
            <summary>
            Device can allocate managed memory on this system.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.IsMultiGpuBoard">
            <summary>
            Device is on a multi-GPU board.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MultiGpuBoardGroupID">
            <summary>
            Unique identifier for a group of devices on the same multi-GPU board.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.HostNativeAtomicSupported">
            <summary>
            Link between the device and the host supports native atomic operations.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.SingleToDoublePrecisionPerfRatio">
            <summary>
            Ratio of single precision performance (in floating-point operations per second) to double precision performance.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.PageableMemoryAccess">
            <summary>
            Device supports coherently accessing pageable memory without calling cudaHostRegister on it.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ConcurrentManagedAccess">
            <summary>
            Device can coherently access managed memory concurrently with the CPU.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.ComputePreemptionSupported">
            <summary>
            Device supports Compute Preemption.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.CanUseHostPointerForRegisteredMem">
            <summary>
            Device can access host registered memory at the same virtual address as the CPU.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.CooperativeLaunch">
            <summary>
            Device supports launching cooperative kernels via cudaLaunchCooperativeKernel.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.CooperativeMultiDeviceLaunch">
            <summary>
            Device can participate in cooperative kernels launched via cudaLaunchCooperativeKernelMultiDevice.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.MaxSharedMemoryPerBlockOptin">
            <summary>
            The maximum optin shared memory per block. This value may vary by chip. See cudaFuncSetAttribute.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.CanFlushRemoteWrites">
            <summary>
            Device supports flushing of outstanding remote writes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.HostRegisterSupported">
            <summary>
            Device supports host memory registration via cudaHostRegister.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.PageableMemoryAccessUsesHostPageTables">
            <summary>
            Device accesses pageable memory via the host's page tables.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DeviceAttribute.cudaDevAttrDirectManagedMemAccessFromHost">
            <summary>
            Host can directly access managed memory on the device without migration.
            </summary>
        </member>
        <member name="T:CSparse.Interop.CUDA.StreamFlags">
            <summary>
            CUDA stream flags
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.StreamFlags.None">
            <summary>
            For compatibilty with pre Cuda 5.0, equal to Default
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.StreamFlags.Default">
            <summary>
            Default stream flag
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.StreamFlags.NonBlocking">
            <summary>
            Stream does not synchronize with stream 0 (the NULL stream)
            </summary>
        </member>
        <member name="T:CSparse.Interop.CUDA.CudaResult">
            <summary>
            Error codes returned by CUDA driver API calls.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.Success">
            <summary>
            The API call returned with no errors.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.MissingConfiguration">
            <summary>
            The device function being invoked (usually via cudaLaunchKernel()) was not
            previously configured via the cudaConfigureCall() function.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.MemoryAllocation">
            <summary>
            The API call failed because it was unable to allocate enough memory to perform the
            requested operation.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InitializationError">
            <summary>
            The API call failed because the CUDA driver and runtime could not be initialized.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchFailure">
            <summary>
            An exception occurred on the device while executing a kernel.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.PriorLaunchFailure">
            <summary>
            DEPRECATED: This indicated that a previous kernel launch failed .
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchTimeout">
            <summary>
            This indicates that the device kernel took too long to execute.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchOutOfResources">
            <summary>
            This indicates that a launch did not occur because it did not have appropriate resources.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidDeviceFunction">
            <summary>
            The requested device function does not exist or is not compiled for the proper device
            architecture.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidConfiguration">
            <summary>
            This indicates that a kernel launch is requesting resources that can never be satisfied
            by the current device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidDevice">
            <summary>
            This indicates that the device ordinal supplied by the user does not correspond to a
            valid CUDA device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidValue">
            <summary>
            This indicates that one or more of the parameters passed to the API call is not within
            an acceptable range of values.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidPitchValue">
            <summary>
            This indicates that one or more of the pitch-related parameters passed to the API call
            is not within the acceptable range for pitch.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidSymbol">
            <summary>
            This indicates that the symbol name/identifier passed to the API call is not a valid
            name or identifier.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.MapBufferObjectFailed">
            <summary>
            This indicates that the buffer object could not be mapped.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.UnmapBufferObjectFailed">
            <summary>
            This indicates that the buffer object could not be unmapped.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidHostPointer">
            <summary>
            This indicates that at least one host pointer passed to the API call is not a valid host
            pointer.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidDevicePointer">
            <summary>
            This indicates that at least one device pointer passed to the API call is not a valid
            device pointer.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidTexture">
            <summary>
            This indicates that the texture passed to the API call is not a valid texture.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidTextureBinding">
            <summary>
            This indicates that the texture binding is not valid.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidChannelDescriptor">
            <summary>
            This indicates that the channel descriptor passed to the API call is not valid.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidMemcpyDirection">
            <summary>
            This indicates that the direction of the memcpy passed to the API call is not one of the
            types specified by cudaMemcpyKind.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.AddressOfConstant">
            <summary>
            DEPRECATED: This indicated that the user has taken the address of a constant variable, which was
            forbidden up until the CUDA 3.1 release.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.TextureFetchFailed">
            <summary>
            DEPRECATED: This indicated that a texture fetch was not able to be performed. This was previously
            used for device emulation of texture operations.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.TextureNotBound">
            <summary>
            DEPRECATED: This indicated that a texture was not bound for access. This was previously used for
            device emulation of texture operations.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.SynchronizationError">
            <summary>
            DEPRECATED: This indicated that a synchronization operation had failed.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidFilterSetting">
            <summary>
            This indicates that a non-float texture was being accessed with linear filtering. This is
            not supported by CUDA.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidNormSetting">
            <summary>
            This indicates that an attempt was made to read a non-float texture as a normalized
            float. This is not supported by CUDA.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.MixedDeviceExecution">
            <summary>
            DEPRECATED: Mixing of device and device emulation code was not allowed.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.CudartUnloading">
            <summary>
            This indicates that a CUDA Runtime API call cannot be executed because it is being
            called during process shut down, at a point in time after CUDA driver has been
            unloaded.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.Unknown">
            <summary>
            This indicates that an unknown internal error has occurred.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NotYetImplemented">
            <summary>
            DEPRECATED: This indicates that the API call is not yet implemented. Production releases of CUDA
            will never return this error.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.MemoryValueTooLarge">
            <summary>
            DEPRECATED: This indicated that an emulated device pointer exceeded the 32-bit address range.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidResourceHandle">
            <summary>
            This indicates that a resource handle passed to the API call was not valid.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NotReady">
            <summary>
            This indicates that asynchronous operations issued previously have not completed
            yet. This result is not actually an error, but must be indicated differently than
            cudaSuccess (which indicates completion). Calls that may return this value include
            cudaEventQuery() and cudaStreamQuery().
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InsufficientDriver">
            <summary>
            This indicates that the installed NVIDIA CUDA driver is older than the CUDA
            runtime library.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.SetOnActiveProcess">
            <summary>
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidSurface">
            <summary>
            This indicates that the surface passed to the API call is not a valid surface.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NoDevice">
            <summary>
            This indicates that no CUDA-capable devices were detected by the installed CUDA
            driver.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.ECCUncorrectable">
            <summary>
            This indicates that an uncorrectable ECC error was detected during execution.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.SharedObjectSymbolNotFound">
            <summary>
            This indicates that a link to a shared object failed to resolve.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.SharedObjectInitFailed">
            <summary>
            This indicates that initialization of a shared object failed.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.UnsupportedLimit">
            <summary>
            This indicates that the cudaLimit passed to the API call is not supported by the active
            device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.DuplicateVariableName">
            <summary>
            This indicates that multiple global or constant variables (across separate CUDA
            source files in the application) share the same string name.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.DuplicateTextureName">
            <summary>
            This indicates that multiple textures (across separate CUDA source files in the
            application) share the same string name.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.DuplicateSurfaceName">
            <summary>
            This indicates that multiple surfaces (across separate CUDA source files in the
            application) share the same string name.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.DevicesUnavailable">
            <summary>
            This indicates that all CUDA devices are busy or unavailable at the current time.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidKernelImage">
            <summary>
            This indicates that the device kernel image is invalid.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NoKernelImageForDevice">
            <summary>
            This indicates that there is no kernel image available that is suitable for the device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.IncompatibleDriverContext">
            <summary>
            This indicates that the current context is not compatible with this the CUDA Runtime.
            This can only occur if you are using CUDA Runtime/Driver interoperability and have
            created an existing Driver context using the driver API.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.PeerAccessAlreadyEnabled">
            <summary>
            This error indicates that a call to cudaDeviceEnablePeerAccess() is trying to re-enable
            peer addressing on from a context which has already had peer addressing enabled.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.PeerAccessNotEnabled">
            <summary>
            This error indicates that cudaDeviceDisablePeerAccess() is trying to disable peer
            addressing which has not been enabled yet via cudaDeviceEnablePeerAccess().
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.DeviceAlreadyInUse">
            <summary>
            This indicates that a call tried to access an exclusive-thread device that is already in
            use by a different thread.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.ProfilerDisabled">
            <summary>
            This indicates profiler is not initialized for this run. This can happen when the
            application is running with external profiling tools like visual profiler.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.ProfilerNotInitialized">
            <summary>
            DEPRECATED: This error return is deprecated as of CUDA 5.0. It is no longer an error
            to attempt to enable/disable the profiling via cudaProfilerStart or cudaProfilerStop
            without initialization.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.ProfilerAlreadyStarted">
            <summary>
            DEPRECATED: This error return is deprecated as of CUDA 5.0. It is no longer an error to
            call cudaProfilerStart() when profiling is already enabled.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.ProfilerAlreadyStopped">
            <summary>
            DEPRECATED: This error return is deprecated as of CUDA 5.0. It is no longer an error to
            call cudaProfilerStop() when profiling is already disabled.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.Assert">
            <summary>
            An assert triggered in device code during kernel execution. The device cannot be
            used again until cudaThreadExit() is called. All existing allocations are invalid and
            must be reconstructed if the program is to continue using CUDA.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.TooManyPeers">
            <summary>
            This error indicates that the hardware resources required to enable peer access have
            been exhausted for one or more of the devices passed to cudaEnablePeerAccess().
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.HostMemoryAlreadyRegistered">
            <summary>
            This error indicates that the memory range passed to cudaHostRegister() has already
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.HostMemoryNotRegistered">
            been registered.
            <summary>
            This error indicates that the pointer passed to cudaHostUnregister() does not
            correspond to any currently registered memory region.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.OperatingSystem">
            <summary>
            This error indicates that an OS call failed.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.PeerAccessUnsupported">
            <summary>
            This error indicates that P2P access is not supported across the given devices.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchMaxDepthExceeded">
            <summary>
            This error indicates that a device runtime grid launch did not occur because the
            depth of the child grid would exceed the maximum supported number of nested grid
            launches.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchFileScopedTex">
            <summary>
            This error indicates that a grid launch did not occur because the kernel uses filescoped
            textures which are unsupported by the device runtime.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchFileScopedSurf">
            <summary>
            This error indicates that a grid launch did not occur because the kernel uses filescoped
            surfaces which are unsupported by the device runtime.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.SyncDepthExceeded">
            <summary>
            This error indicates that a call to cudaDeviceSynchronize made from the
            device runtime failed because the call was made at grid depth greater
            than than either the default (2 levels of grids) or user specified device
            limit cudaLimitDevRuntimeSyncDepth.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.LaunchPendingCountExceeded">
            <summary>
            This error indicates that a device runtime grid launch failed because the launch
            would exceed the limit cudaLimitDevRuntimePendingLaunchCount.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NotPermitted">
            <summary>
            This error indicates the attempted operation is not permitted.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NotSupported">
            <summary>
            This error indicates the attempted operation is not supported on the current system
            or device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.HardwareStackError">
            <summary>
            Device encountered an error in the call stack during kernel execution, possibly due
            to stack corruption or exceeding the stack size limit.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.IllegalInstruction">
            <summary>
            The device encountered an illegal instruction during kernel execution.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.MisalignedAddress">
            <summary>
            The device encountered a load or store instruction on a memory address which is not
            aligned.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidAddressSpace">
            <summary>
            While executing a kernel, the device encountered an instruction which can only
            operate on memory locations in certain address spaces (global, shared, or local),
            but was supplied a memory address not belonging to an allowed address space.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidPc">
            <summary>
            The device encountered an invalid program counter.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.IllegalAddress">
            <summary>
            The device encountered a load or store instruction on an invalid memory address.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidPtx">
            <summary>
            A PTX compilation failed. The runtime may fall back to compiling PTX if an
            application does not contain a suitable binary for the current device.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.InvalidGraphicsContext">
            <summary>
            This indicates an error with the OpenGL or DirectX context.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.NvlinkUncorrectable">
            <summary>
            This indicates that an uncorrectable NVLink error was detected during the execution.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.JitCompilerNotFound">
            <summary>
            This indicates that the PTX JIT compiler library was not found.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.CooperativeLaunchTooLarge">
            <summary>
            This error indicates that the number of blocks launched per grid for a
            kernel that was launched via either cudaLaunchCooperativeKernel or
            cudaLaunchCooperativeKernelMultiDevice exceeds the maximum number
            of blocks.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.StartupFailure">
            <summary>
            This indicates an internal startup failure in the CUDA runtime.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.CudaResult.ApiFailureBase">
            <summary>
            Any unhandled CUDA driver error is added to this value and returned via the
            runtime. Production releases of CUDA should not return such errors. Deprecated
            This error return is deprecated as of CUDA 4.1.
            </summary>
        </member>
        <member name="T:CSparse.Interop.CUDA.MemcpyKind">
            <summary>
            CUDA memory copy types.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MemcpyKind.HostToHost">
            <summary>
            Host -> Host
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MemcpyKind.HostToDevice">
            <summary>
            Host -> Device
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MemcpyKind.DeviceToHost">
            <summary>
            Device -> Host
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MemcpyKind.DeviceToDevice">
            <summary>
            Device -> Device
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MemcpyKind.Default">
            <summary>
            Direction of the transfer
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.Success">
            <summary>
            The operation completed successfully.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.NotInitialized">
            <summary>
            The CUSPARSE library was not initialized. 
            </summary>
            <remarks>
            This is usually caused by the lack of a prior cusparseCreate() call, an error in the
            CUDA Runtime API called by the CUSPARSE routine, or an error in the hardware setup.
            To correct: call cusparseCreate() prior to the function call; and check that the hardware,
            an appropriate version of the driver, and the CUSPARSE library are correctly installed.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.AllocFailed">
            <summary>
            Resource allocation failed inside the CUSPARSE library. 
            </summary>
            <remarks>
            This is usually caused by a 
            cudaMalloc() failure. To correct: prior to the function call, deallocate previously allocated
            memory as much as possible.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.InvalidValue">
            <summary>
            An unsupported value or parameter was passed to the function (a negative vector size, for example). 
            </summary>
            <remarks>
            To correct: ensure that all the parameters being passed have valid values.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.ArchMismatch">
            <summary>
            The function requires a feature absent from the device architecture; 
            </summary>
            <remarks>
            Usually caused by the lack of support for atomic operations or double precision.
            To correct: compile and run the application on a device with appropriate compute capability,
            which is 1.1 for 32-bit atomic operations and 1.3 for double precision.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.MappingError">
            <summary>
            An access to GPU memory space failed, which is usually caused by a failure to bind a texture.
            </summary>
            <remarks>
            To correct: prior to the function call, unbind any previously bound textures.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.ExecutionFailed">
            <summary>
            The GPU program failed to execute. 
            </summary>
            <remarks>
            This is often caused by a launch failure of the kernel on the GPU, which can be
            caused by multiple reasons. To correct: check that the hardware, an appropriate
            version of the driver, and the CUSPARSE library are correctly installed.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.InternalError">
            <summary>
            An internal CUSPARSE operation failed. 
            </summary>
            <remarks>
            This error is usually caused by a cudaMemcpyAsync() failure. To correct: check that the hardware,
            an appropriate version of the driver, and the CUSPARSE library are correctly installed. Also,
            check that the memory passed as a parameter to the routine is not being deallocated prior to
            the routine's completion.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.MatrixTypeNotSupported">
            <summary>
            The matrix type is not supported by this function. 
            </summary>
            <remarks>
            This is usually caused by passing an invalid matrix descriptor to the function.
            To correct: check that the fields in IntPtr_t descrA were set correctly.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SparseStatus.ZeroPivot">
             <summary>
            
             </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MatrixType.General">
            <summary>
            the matrix is general.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MatrixType.Symmetric">
            <summary>
            the matrix is symmetric.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MatrixType.Hermitian">
            <summary>
            the matrix is Hermitian.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.MatrixType.Triangular">
            <summary>
            the matrix is triangular.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.FillMode.Lower">
            <summary>
            the lower triangular part is stored.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.FillMode.Upper">
            <summary>
            the upper triangular part is stored.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DiagonalType.NonUnit">
            <summary>
            the matrix diagonal has non-unit elements.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.DiagonalType.Unit">
            <summary>
            the matrix diagonal has unit elements.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.IndexBase.Zero">
            <summary>
            the base index is zero.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.IndexBase.One">
            <summary>
            the base index is one.
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.Success">
            <summary>
            The operation completed successfully
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.NotInititialized">
            <summary>
            The cuSolver library was not initialized. 
            </summary>
            <remarks>
            This is usually caused by the lack of a prior call, an error in the CUDA Runtime
            API called by the cuSolver routine, or an error in the hardware setup.
            To correct: call cusolverCreate() prior to the function call; and
            check that the hardware, an appropriate version of the driver, and the
            cuSolver library are correctly installed.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.AllocFailed">
            <summary>
            Resource allocation failed inside the cuSolver library. 
            </summary>
            <remarks>
            This is usually caused by a cudaMalloc() failure.
            To correct: prior to the function call, deallocate previously allocated
            memory as much as possible.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.InvalidValue">
            <summary>
            An unsupported value or parameter was passed to the function (a negative vector size, for example).
            </summary>
            <remarks>
            To correct: ensure that all the parameters being passed have valid values.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.ArchMismatch">
            <summary>
            The function requires a feature absent from the device architecture.
            <remarks>
            Usually caused by the lack of support for atomic operations or double precision.
            To correct: compile and run the application on a device with compute capability 2.0 or above.
            </remarks>
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.MappingError">
            <summary>
            
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.ExecutionFailed">
            <summary>
            The GPU program failed to execute.
            </summary>
            <remarks>
            This is often caused by a launch failure of the kernel on the GPU, which
            can be caused by multiple reasons.
            To correct: check that the hardware, an appropriate version of the
            driver, and the cuSolver library are correctly installed.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.InternalError">
            <summary>
            An internal cuSolver operation failed.
            </summary>
            <remarks>
            This error is usually caused by a cudaMemcpyAsync() failure.
            To correct: check that the hardware, an appropriate version of the
            driver, and the cuSolver library are correctly installed. Also, check
            that the memory passed as a parameter to the routine is not being
            deallocated prior to the routine's completion.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.MatrixTypeNotSupported">
            <summary>
            The matrix type is not supported by this function.
            </summary>
            <remarks>
            This is usually caused by passing an invalid matrix descriptor to the function.
            To correct: check that the fields in descrA were set correctly.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.NotSupported">
            <summary>
            
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.ZeroPivot">
            <summary>
            
            </summary>
        </member>
        <member name="F:CSparse.Interop.CUDA.SolverStatus.InvalidLicense">
            <summary>
            
            </summary>
        </member>
        <member name="T:CSparse.Interop.Feast.FeastContext`1">
            <summary>
            FEAST eigenvalue solver (MKL supports real symmetric or complex Hermetian matrices only).
            </summary>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initialize the standard eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0},CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initialize the generalized eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.SolveStandard(System.Int32,System.Double,System.Double)">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="m0">The initial guess for subspace dimension.</param>
            <param name="emin">The lower bound of the interval to be searched for eigenvalues.</param>
            <param name="emax">The upper bound of the interval to be searched for eigenvalues.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.SolveStandard(System.Int32,System.Double,System.Double,CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="m0">The initial guess for subspace dimension.</param>
            <param name="emin">The lower bound of the interval to be searched for eigenvalues.</param>
            <param name="emax">The upper bound of the interval to be searched for eigenvalues.</param>
            <param name="subspace">The subspace containing the eigenvectors (can be used for an initial guess).</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.SolveGeneralized(System.Int32,System.Double,System.Double)">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
            <param name="m0">The initial guess for subspace dimension.</param>
            <param name="emin">The lower bound of the interval to be searched for eigenvalues.</param>
            <param name="emax">The upper bound of the interval to be searched for eigenvalues.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.SolveGeneralized(System.Int32,System.Double,System.Double,CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
            <param name="m0">The initial guess for subspace dimension.</param>
            <param name="emin">The lower bound of the interval to be searched for eigenvalues.</param>
            <param name="emax">The upper bound of the interval to be searched for eigenvalues.</param>
            <param name="subspace">The subspace containing the eigenvectors (can be used for an initial guess).</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.Increment(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            FEAST uses 1-based indexing (FORTRAN style).
            </summary>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastContext`1.Decrement(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            FEAST uses 1-based indexing (FORTRAN style).
            </summary>
        </member>
        <member name="F:CSparse.Interop.Feast.FeastMode.Standard">
            <summary>
            Normal execution.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Feast.FeastMode.SingleIntegration">
            <summary>
            Return the computed eigenvectors subspace after one single contour integration.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.PrintStatus">
            <summary>
            Specifies whether Extended Eigensolver routines print runtime status. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.ContourPoints">
            <summary>
            The number of contour points (default = 8).
            </summary>
            <remarks>
            Must be one of {3,4,5,6,8,10,12,16,20,24,32,40,48}.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.TraceThreshold">
            <summary>
            Error trace double precision stopping criteria (10^-k, default = 12). 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.Refinement">
            <summary>
            Maximum number of Extended Eigensolver refinement loops allowed. 
            </summary>
            <remarks>
            If no convergence is reached within specified refinement loops,
            Extended Eigensolver routines return info=2.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.CustomInitialSubspace">
            <summary>
            Use custom initial subspace (default = false). 
            </summary>
            <remarks>
            If false, then Extended Eigensolver routines generate initial subspace,
            if true the user supplied initial subspace is used.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.UseTraceStoppingTest">
            <summary>
            Use residual or trace stopping test.
            </summary>
            <remarks>
            If true, Extended Eigensolvers are stopped if residual stopping
            test is satisfied, otherwise trace stopping test is applied.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.SingleTraceThreshold">
            <summary>
            Error trace single precision stopping criteria (10^-k, default = 5). 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.Usage">
            <summary>
            Standard use for Extended Eigensolver routines.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.CheckInput">
            <summary>
            Specifies whether Extended Eigensolver routines check input
            matrices (applies to CSR format only).
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.CheckPositiveDefinite">
            <summary>
            Check if matrix B is positive definite.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastOptions.CustomParadiso">
            <summary>
            Use the PARDISO solver with the user-defined options.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Feast.FeastOptions.fpm">
            <summary>
            The underlying FEAST options array.
            </summary>
            <remarks>
            See https://software.intel.com/en-us/mkl-developer-reference-c-extended-eigensolver-input-parameters.
            </remarks>
        </member>
        <member name="T:CSparse.Interop.Feast.FeastResult`1">
            <summary>
            FEAST result.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Feast.FeastResult`1.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,System.Int32,System.Double[],CSparse.Storage.DenseColumnMajorStorage{`0},System.Double[])">
            <summary>
            Initializes a new instance of the FeastResult class.
            </summary>
            <param name="info">The status returned by FEAST.</param>
            <param name="m0">The number of eigenvalues requested.</param>
            <param name="size">The matrix size.</param>
            <param name="loops">The number of refinement loops executed.</param>
            <param name="error">The relative error on the trace.</param>
            <param name="m">The number of eigenvalues found (m &lt; m0).</param>
            <param name="e">Array of length m0. The first m entries of e are eigenvalues found in the interval.</param>
            <param name="x">Matrix with m0 columns containing the orthonormal eigenvectors corresponding to the
            computed eigenvalues e, with the i-th column of x holding the eigenvector associated with e[i].</param>
            <param name="r">Array of length m0 containing the relative residual vector (in the first m components).</param>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.Status">
            <summary>
            Gets the status code returned by FEAST.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.SubspaceDimension">
            <summary>
            Gets the subspace dimension.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.RefinementLoops">
            <summary>
            Gets the number of refinement loop executed.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.RelativeTraceError">
            <summary>
            Gets the relative error on the trace.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.ConvergedEigenvalues">
            <summary>
            Gets the number of converged eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.EigenVectors">
            <summary>
            Gets the dense matrix of eigenvectors stored in column major order.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.EigenValues">
            <summary>
            Gets the eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Feast.FeastResult`1.RelativeResiduals">
            <summary>
            Gets the relative residuals vector.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Feast.NativeMethods.feastinit(System.Int32[])">
            <summary>
            Initialize Extended Eigensolver input parameters with default values.
            </summary>
            <param name="fpm">Array, size 128. This array is used to pass various parameters to Extended Eigensolver routines.</param>
        </member>
        <member name="T:CSparse.Interop.Metis.MetisGraph">
            <summary>
            Adjacency structure of the graph.
            </summary>
            <remarks>
            The adjacency structure of the graph is stored using the compressed storage format (CSR).
            The CSR format is a widely used scheme for storing sparse graphs. In this format the
            adjacency structure of a graph with n vertices and m edges is represented using two arrays
            xadj and adjncy. The xadj array is of size n + 1 whereas the adjncy array is of size 2m
            (this is because for each edge between vertices v and u we actually store both (v; u) and
            (u; v)).
            
            The adjacency structure of the graph is stored as follows. Assuming that vertex numbering
            starts from 0 (C style), then the adjacency list of vertex i is stored in array adjncy
            starting at index xadj[i] and ending at (but not including) index xadj[i+1] (i.e.,
            adjncy[xadj[i]] through and including adjncy[xadj[i+1]-1]). That is, for each vertex i,
            its adjacency list is stored in consecutive locations in the array adjncy, and the array
            xadj is used to point to where it begins and where it ends.
            
            The weights of the vertices (if any) are stored in an additional array called vwgt. If ncon
            is the number of weights associated with each vertex, the array vwgt contains n * ncon
            elements (recall that n is the number of vertices). The weights of the ith vertex are
            stored in ncon consecutive entries starting at location vwgt[i * ncon]. Note that if each
            vertex has only a single weight, then vwgt will contain n elements, and vwgt[i] will store
            the weight of the ith vertex. The vertex-weights must be integers greater or equal to zero.
            If all the vertices of the graph have the same weight (i.e., the graph is unweighted), then
            the vwgt can be set to NULL.
            
            The weights of the edges (if any) are stored in an additional array called adjwgt. This
            array contains 2m elements, and the weight of edge adjncy[j] is stored at location adjwgt[j].
            The edge-weights must be integers greater than zero. If all the edges of the graph have the
            same weight (i.e., the graph is unweighted), then the adjwgt can be set to NULL.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisGraph.VertexCount">
            <summary>
            Gets the number of vertices in the graph.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisGraph.EdgeCount">
            <summary>
            Gets the number of edges in the graph.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisGraph.Pointers">
            <summary>
            Gets the adjacency pointers.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisGraph.Indices">
            <summary>
            Gets the adjacency indices.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisGraph.VertexWeights">
            <summary>
            Gets the vertex weights.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisGraph.EdgeWeights">
            <summary>
            Gets the weights of the adjacency lists.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisGraph.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Metis.MetisGraph"/> class.
            </summary>
            <param name="nvtxs">The number of vertices.</param>
            <param name="nedges">The number of edges.</param>
            <param name="xadj">Pointers to the locally stored vertices.</param>
            <param name="adjncy">The adjacency lists.</param>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisGraph.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Metis.MetisGraph"/> class.
            </summary>
            <param name="nvtxs">The number of vertices.</param>
            <param name="nedges">The number of edges.</param>
            <param name="xadj">Pointers to the locally stored vertices.</param>
            <param name="adjncy">The adjacency lists.</param>
            <param name="vwgt">Vertex weights.</param>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisGraph.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Metis.MetisGraph"/> class.
            </summary>
            <param name="nvtxs">The number of vertices.</param>
            <param name="nedges">The number of edges.</param>
            <param name="xadj">Pointers to the locally stored vertices.</param>
            <param name="adjncy">The adjacency lists.</param>
            <param name="vwgt">Vertex weights.</param>
            <param name="adjwgt">The weights of the adjacency lists.</param>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisGraph.PartitionKway(System.Int32,System.Int32[],CSparse.Interop.Metis.MetisOptions)">
            <summary>
            Partition a graph into k parts using multilevel k-way partitioning.
            </summary>
            <param name="k">The number of partitions.</param>
            <param name="part">Target array storing the partition of the graph (size nvtxs).</param>
            <param name="options">Partitioning options.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisGraph.PartitionRecursive(System.Int32,System.Int32[],CSparse.Interop.Metis.MetisOptions)">
            <summary>
            Partition a graph into k parts using multilevel recursive bisection partitioning.
            </summary>
            <param name="k">The number of partitions.</param>
            <param name="part">Target array storing the partition of the graph (size nvtxs).</param>
            <param name="options">Partitioning options.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisGraph.NestedDissection(System.Int32[],System.Int32[],CSparse.Interop.Metis.MetisOptions)">
            <summary>
            Computes fill reducing orderings of sparse matrices using the multilevel nested dissection algorithm.
            </summary>
            <param name="perm">Target array storing the fill-reducing permutaion (size nvtxs).</param>
            <param name="iperm">Target array storing the fill-reducing inverse permutaion (size nvtxs).</param>
            <param name="options">Partitioning options.</param>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.Metis.MetisMesh">
            <summary>
            Mesh adjacency data structure.
            </summary>
            <remarks>
            All of the mesh partitioning and mesh conversion routines in METIS take as input the
            element node array of a mesh. This element node array is stored using a pair of arrays
            called eptr and eind, which are similar to the xadj and adjncy arrays used for storing
            the adjacency structure of a graph.
            
            The size of the eptr array is n+1, where n is the number of elements in the mesh. The
            size of the eind array is of size equal to the sum of the number of nodes in all the
            elements of the mesh. The list of nodes belonging to the ith element of the mesh are
            stored in consecutive locations of eind starting at position eptr[i] up to (but not
            including) position eptr[i+1].
            
            This format makes it easy to specify meshes of any type of elements, including meshes with
            mixed element types that have different number of nodes per element. The ordering of the
            nodes in each element is not important.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisMesh.NodeCount">
            <summary>
            Gets the number of nodes.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisMesh.ElementCount">
            <summary>
            Gets the number of elements.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisMesh.ElementPointers">
            <summary>
            Gets the element pointers.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisMesh.ElementIndices">
            <summary>
            Gets the element indices.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisMesh.ElementWeights">
            <summary>
            Gets the element weights.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisMesh.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Metis.MetisMesh"/> class.
            </summary>
            <param name="nn">The number of nodes in the mesh</param>
            <param name="ne">The number of elements in the mesh</param>
            <param name="eptr">The element pointers.</param>
            <param name="eind">The element indices.</param>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisMesh.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Metis.MetisMesh"/> class.
            </summary>
            <param name="nn">The number of nodes in the mesh</param>
            <param name="ne">The number of elements in the mesh</param>
            <param name="eptr">The element pointers.</param>
            <param name="eind">The element indices.</param>
            <param name="ewgt">The weights of the elements.</param>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisMesh.PartitionDual(System.Int32,System.Int32[],System.Int32[],CSparse.Interop.Metis.MetisOptions)">
            <summary>
            Partition a mesh into k parts based on a partitioning of the mesh's dual graph.
            </summary>
            <param name="k">The number of partitions.</param>
            <param name="epart">Target array storing the element partition (size ne).</param>
            <param name="npart">Target array storing the node partition (size nn).</param>
            <param name="options">Partitioning options.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisMesh.PartitionNodal(System.Int32,System.Int32[],System.Int32[],CSparse.Interop.Metis.MetisOptions)">
            <summary>
            Partition a mesh into k parts based on a partitioning of the mesh's nodal graph.
            </summary>
            <param name="k">The number of partitions.</param>
            <param name="epart">Target array storing the element partition (size ne).</param>
            <param name="npart">Target array storing the node partition (size nn).</param>
            <param name="options">Partitioning options.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisMesh.ToDualGraph(System.Int32)">
            <summary>
            Generate the dual graph of a mesh.
            </summary>
            <param name="ncommon">Specifies the number of common nodes that two elements must have in
            order to put an edge between them in the dual graph.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisMesh.ToNodalGraph">
            <summary>
            Generate the nodal graph of a mesh.
            </summary>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.Metis.PartitioningType">
            <summary>
            Specifies the partitioning method.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.PartitioningType.RB">
            <summary>
            Multilevel recursive bisectioning.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.PartitioningType.KWAY">
            <summary>
            Multilevel k-way partitioning.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Metis.ObjectiveType">
            <summary>
            Specifies the type of objective.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.ObjectiveType.CUT">
            <summary>
            Edge-cut minimization.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.ObjectiveType.VOL">
            <summary>
            Total communication volume minimization.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.ObjectiveType.NODE">
            <summary>
            Only used for graph ordering.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Metis.CoarseningType">
            <summary>
            Specifies the matching scheme to be used during coarsening.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.CoarseningType.RM">
            <summary>
            Random matching.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.CoarseningType.SHEM">
            <summary>
            Sorted heavy-edge matching.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Metis.InitialPartitioningType">
            <summary>
            Determines the algorithm used during initial partitioning.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.InitialPartitioningType.GROW">
            <summary>
            Grows a bisection using a greedy strategy.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.InitialPartitioningType.RANDOM">
            <summary>
            Computes a bisection at random followed by a refinement.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.InitialPartitioningType.EDGE">
            <summary>
            Derives a separator from an edge cut.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.InitialPartitioningType.NODE">
            <summary>
            Grow a bisection using a greedy node-based strategy.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Metis.RefinementType">
            <summary>
            Determines the algorithm used for refinement.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.RefinementType.FM">
            <summary>
            FM-based cut refinement.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.RefinementType.GREEDY">
            <summary>
            Greedy-based cut and volume refinement.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.RefinementType.SEP2SIDED">
            <summary>
            Two-sided node FM refinement.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.RefinementType.SEP1SIDED">
            <summary>
            One-sided node FM refinement.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.INFO">
            <summary>
            Shows various diagnostic messages
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.TIME">
            <summary>
            Perform timing analysis
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.COARSEN">
            <summary>
            Show the coarsening progress
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.REFINE">
            <summary>
            Show the refinement progress
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.IPART">
            <summary>
            Show info on initial partitioning
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.MOVEINFO">
            <summary>
            Show info on vertex moves during refinement
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.SEPINFO">
            <summary>
            Show info on vertex moves during sep refinement
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.CONNINFO">
            <summary>
            Show info on minimization of subdomain connectivity
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.CONTIGINFO">
            <summary>
            Show info on elimination of connected components
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.DebugLevel.MEMORY">
            <summary>
            Show info related to wspace allocation
            </summary>
        </member>
        <member name="T:CSparse.Interop.Metis.MetisOptions">
            <summary>
            Metis options.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Partitioning">
            <summary>
            Specifies the partitioning method.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Objective">
            <summary>
            Specifies the type of objective.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Coarsening">
            <summary>
            Specifies the matching scheme to be used during coarsening.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.InitialPartitioning">
            <summary>
            Determines the algorithm used during initial partitioning.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Refinement">
            <summary>
            Determines the algorithm used for refinement.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Cuts">
            <summary>
            Specifies the number of different partitionings that it will compute
            (default is 1).
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Seperators">
            <summary>
            Specifies the number of different separators that it will compute at 
            each level of nested dissection (default is 1).
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Iterations">
            <summary>
            Specifies the number of iterations for the refinement algorithms at 
            each stage of the uncoarsening process.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Seed">
            <summary>
            Specifies the seed for the random number generator.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.No2Hop">
            <summary>
            Specifies that the coarsening will not perform any 2–hop matchings when the standard matching approach
            fails to sufficiently coarsen the graph. The 2–hop matching is very effective for graphs with power-law
            degree distributions.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.MinConnect">
            <summary>
            Specifies that the partitioning routines should try to minimize the maximum
            degree of the subdomain graph, i.e., the graph in which each partition is
            a node, and edges connect subdomains with a shared interface.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Contiguous">
            <summary>
            Specifies that the partitioning routines should try to produce partitions
            that are contiguous. Note that if the input graph is not connected this option
            is ignored.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.Compress">
            <summary>
            Specifies that the graph should be compressed by combining together vertices 
            that have identical adjacency lists.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.ComponentOrder">
            <summary>
            Specifies if the connected components of the graph should first be identified 
            and ordered separately.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.PFactor">
            <summary>
            Specifies the minimum degree of the vertices that will be ordered last.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.UFactor">
            <summary>
            Specifies the maximum allowed load imbalance among the partitions.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Metis.MetisOptions.DebugLevel">
            <summary>
            Specifies the partitioning method.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Metis.MetisOptions"/> class.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisOptions.GraphPartitionDefault">
            <summary>
            Creates a new instance of the <see cref="T:CSparse.Interop.Metis.MetisOptions"/> class with default graph partitioning options.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisOptions.MeshPartitionDefault">
            <summary>
            Creates a new instance of the <see cref="T:CSparse.Interop.Metis.MetisOptions"/> class with default mesh partitioning options.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Metis.MetisOptions.NestedDissectionDefault">
            <summary>
            Creates a new instance of the <see cref="T:CSparse.Interop.Metis.MetisOptions"/> class with default nested dissection ordering options.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.MetisStatus.OK">
            <summary>
            Returned normally
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.MetisStatus.ERROR_INPUT">
            <summary>
            Returned due to erroneous inputs and/or options
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.MetisStatus.ERROR_MEMORY">
            <summary>
            Returned due to insufficient memory
            </summary>
        </member>
        <member name="F:CSparse.Interop.Metis.MetisStatus.ERROR">
            <summary>
            Some other errors
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.Metis.NativeMethods.PartGraphRecursive(System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr)" -->
        <member name="M:CSparse.Interop.Metis.NativeMethods.PartGraphKway(System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr)">
            <summary>
            Partition a graph into k parts using multilevel k-way partitioning.
            </summary>
            <param name="nvtxs">The number of vertices in the graph.</param>
            <param name="ncon">The number of balancing constraints. It should be at least 1.</param>
            <param name="xadj">The adjacency structure of the graph.</param>
            <param name="adjncy">The adjacency structure of the graph.</param>
            <param name="vwgt">The weights of the vertices (may be null pointer).</param>
            <param name="vsize">The size of the vertices for computing the total communication
            volume (may be null pointer).</param>
            <param name="adjwgt">The weights of the edges as described (may be null pointer).</param>
            <param name="nparts">The number of parts to partition the graph.</param>
            <param name="tpwgts">Floating point array of size (nparts x ncon) that specifies the 
            desired weight for each partition and constraint (may be null pointer).</param>
            <param name="ubvec">Floating point array of size (ncon) that specifies the allowed load 
            imbalance tolerance for each constraint (may be null pointer).</param>
            <param name="options">Array of options (may be null pointer).</param>
            <param name="objval">Upon successful completion, this variable stores the edge-cut or 
            the total communication volume of the partitioning solution.</param>
            <param name="part">This is a vector of size nvtxs that upon successful completion stores 
            the partition vector of the graph.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.PartMeshDual(System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr,System.IntPtr)">
            <summary>
            Partition a mesh into k parts based on a partitioning of the mesh's dual graph.
            </summary>
            <param name="ne">The number of elements in the mesh.</param>
            <param name="nn">The number of nodes in the mesh.</param>
            <param name="eptr">Array storing the mesh.</param>
            <param name="eind">Array storing the mesh.</param>
            <param name="vwgt">Array of size (ne) specifying the weights of the elements (may be 
            null pointer).</param>
            <param name="vsize">Array of size (ne) specifying the size of the elements that is used 
            for computing the total communication volume (may be null pointer).</param>
            <param name="ncommon">Specifies the number of common nodes that two elements must have in 
            order to put an edge between them in the dual graph.</param>
            <param name="nparts">The number of parts to partition the mesh.</param>
            <param name="tpwgts">Array of size nparts that specifies the desired weight for each 
            partition (may be null pointer).</param>
            <param name="options">Array of options (may be null pointer).</param>
            <param name="objval">Upon successful completion, this variable stores either the edgecut 
            or the total communication volume of the dual graph's partitioning.</param>
            <param name="epart">Vector of size ne that upon successful completion stores the partition 
            vector for the elements of the mesh.</param>
            <param name="npart">Vector of size nn that upon successful completion stores the partition 
            vector for the nodes of the mesh.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.PartMeshNodal(System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr,System.IntPtr)">
            <summary>
            Partition a mesh into k parts based on a partitioning of the mesh's nodal graph.
            </summary>
            <param name="ne">The number of elements in the mesh.</param>
            <param name="nn">The number of nodes in the mesh.</param>
            <param name="eptr">Array storing the mesh.</param>
            <param name="eind">Array storing the mesh.</param>
            <param name="vwgt">Array of size (nn) specifying the weights of the nodes (may be 
            null pointer).</param>
            <param name="vsize">Array of size (nn) specifying the size of the nodes that is used 
            for computing the total communication volume (may be null pointer).</param>
            <param name="nparts">The number of parts to partition the mesh.</param>
            <param name="tpwgts">Array of size (nparts) that specifies the desired weight for each 
            partition (may be null pointer).</param>
            <param name="options">Array of options (may be null pointer).</param>
            <param name="objval">Upon successful completion, this variable stores either the edgecut 
            or the total communication volume of the nodal graph's partitioning.</param>
            <param name="epart">Vector of size ne that upon successful completion stores the partition 
            vector for the elements of the mesh.</param>
            <param name="npart">Vector of size nn that upon successful completion stores the partition 
            vector for the nodes of the mesh.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.NodeND(System.Int32@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes fill reducing orderings of sparse matrices using the multilevel nested
            dissection algorithm.
            </summary>
            <param name="nvtxs">The number of vertices in the graph.</param>
            <param name="xadj">Adjacency structure of the graph.</param>
            <param name="adjncy">Adjacency structure of the graph.</param>
            <param name="vwgt">Array of size (nvtxs) specifying the weights of the vertices (may be 
            null pointer).</param>
            <param name="options">Array of options (may be null pointer).</param>
            <param name="perm">Upon successful completion, vectors of size (nvtxs) storing the 
            fill-reducing permutation.</param>
            <param name="iperm">Upon successful completion, vectors of size (nvtxs) storing the 
            fill-reducing inverse-permutation.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.MeshToDual(System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.Int32@,System.Int32@,System.IntPtr@,System.IntPtr@)">
            <summary>
            Generate the dual graph of a mesh.
            </summary>
            <param name="ne">The number of elements in the mesh.</param>
            <param name="nn">The number of nodes in the mesh.</param>
            <param name="eptr">Array storing the mesh.</param>
            <param name="eind">Array storing the mesh.</param>
            <param name="ncommon">Specifies the number of common nodes that two elements must have in
            order to put an edge between them in the dual graph.</param>
            <param name="numflag">Used to indicate which numbering scheme is used for eptr and eind.</param>
            <param name="xadj">Arrays storing the adjacency structure of the generated dual graph.</param>
            <param name="adjncy">Arrays storing the adjacency structure of the generated dual graph.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.MeshToNodal(System.Int32@,System.Int32@,System.IntPtr,System.IntPtr,System.Int32@,System.IntPtr@,System.IntPtr@)">
            <summary>
            Generate the nodal graph of a mesh.
            </summary>
            <param name="ne">The number of elements in the mesh.</param>
            <param name="nn">The number of nodes in the mesh.</param>
            <param name="eptr">Array storing the mesh.</param>
            <param name="eind">Array storing the mesh.</param>
            <param name="numflag">Used to indicate which numbering scheme is used for eptr and eind.</param>
            <param name="xadj">Arrays storing the adjacency structure of the generated dual graph.</param>
            <param name="adjncy">Arrays storing the adjacency structure of the generated dual graph.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.SetDefaultOptions(System.Int32[])">
            <summary>
            Initializes the options array into its default values.
            </summary>
            <param name="options">The array of options that will be initialized.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="M:CSparse.Interop.Metis.NativeMethods.Free(System.IntPtr)">
            <summary>
            Frees the memory that was allocated by either the MeshToDual or the MeshToNodal
            routines for returning the dual or nodal graph of a mesh.
            </summary>
            <param name="ptr">The pointer to be freed. This pointer should be one of the xadj or adjncy 
            returned by METIS API routines.</param>
            <returns>Error indicator.</returns>
        </member>
        <member name="T:CSparse.Interop.MKL.ExtendedEigensolverContext`1">
            <summary>
            Extended eigensolver (MKL 2019.0 supports real symmetric matrices only).
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.ErrorTolerance">
            <summary>
            Gets or sets tolerance.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.Algorithm">
            <summary>
            Gets or sets algorithm used to compute eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.LanczosVectors">
            <summary>
            Gets or sets the number of Lanczos vectors generated at each iteration (Krylov-Schur only).
            </summary>
            <remarks>
            This parameter must be less than or equal to size of matrix and greater than number of eigenvalues (k0) to be computed.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.MaxIterations">
            <summary>
            Gets or sets maximum iteration number.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.ChebychevExpansion">
            <summary>
            Gets or sets power of Chebychev expansion for approximate spectral projector (Krylov-Schur only).
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.ComputeEigenvectors">
            <summary>
            Gets or sets a value indicating whether eigenvectors should be computed (Krylov-Schur only).
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.UseAbsoluteError">
            <summary>
            Gets or sets a value indicating whether the absolute stopping criteria applies.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverContext`1.UseTrueResidual">
            <summary>
            Gets or sets a value indicating whether the true residual should be used.
            </summary>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initialize the standard eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0},CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initialize the generalized eigenvalue problem.
            </summary>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverContext`1.SolveStandard(System.Int32,CSparse.Interop.MKL.Job)">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="k0">The initial guess for subspace dimension.</param>
            <param name="job"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverContext`1.SolveStandard(System.Int32,CSparse.Interop.MKL.Job,CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="k0">The initial guess for subspace dimension.</param>
            <param name="job"></param>
            <param name="subspace">The subspace containing the eigenvectors (can be used for an initial guess).</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverContext`1.SolveGeneralized(System.Int32,CSparse.Interop.MKL.Job)">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
            <param name="k0">The initial guess for subspace dimension.</param>
            <param name="job"></param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverContext`1.SolveGeneralized(System.Int32,CSparse.Interop.MKL.Job,CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
            <param name="k0">The initial guess for subspace dimension.</param>
            <param name="job"></param>
            <param name="subspace">The subspace containing the eigenvectors (can be used for an initial guess).</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverResult`1.#ctor(CSparse.Interop.MKL.SparseStatus,System.Int32,System.Int32,System.Double[],CSparse.Matrix{`0},System.Double[])">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.MKL.ExtendedEigensolverResult`1"/> class.
            </summary>
            <param name="info">The status returned by Intel's extended eigensolver.</param>
            <param name="size">The matrix size.</param>
            <param name="k">The number of eigenvalues found (k &lt; k0).</param>
            <param name="e">Array of length k0. The first k entries of e are eigenvalues found in the interval.</param>
            <param name="x">Matrix with k0 columns containing the orthonormal eigenvectors corresponding to the
            computed eigenvalues e, with the i-th column of x holding the eigenvector associated with e[i].</param>
            <param name="r">Array of length k0 containing the relative residual vector (in the first k components).</param>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverResult`1.Status">
            <summary>
            Gets the status code returned by FEAST.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverResult`1.ConvergedEigenvalues">
            <summary>
            Gets the number of converged eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverResult`1.EigenVectors">
            <summary>
            Gets the dense matrix of eigenvectors stored in column major order.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverResult`1.EigenValues">
            <summary>
            Gets the eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Interop.MKL.ExtendedEigensolverResult`1.Residuals">
            <summary>
            Gets the residuals vector.
            </summary>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverResult`1.EigenValuesReal">
            <summary>
            Gets the real part of the eigenvalues.
            </summary>
        </member>
        <member name="M:CSparse.Interop.MKL.ExtendedEigensolverResult`1.EigenVectorsReal">
            <summary>
            Gets the real part of the eigenvectors.
            </summary>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_get_version(CSparse.Interop.MKL.MKLVersion@)">
            <summary>
            Returns the Intel MKL version.
            </summary>
            <param name="version">MKL version</param>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_get_version_string(System.Text.StringBuilder,System.Int32)">
            <summary>
            Returns the Intel MKL version in a character string.
            </summary>
            <param name="buf">Source string</param>
            <param name="len">Length of the source string</param>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_set_num_threads(System.Int32)">
            <summary>
            Specifies the number of OpenMP threads to use.
            </summary>
            <param name="nt">The number of threads suggested by the user.</param>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_set_num_threads_local(System.Int32)">
            <summary>
            Specifies the number of OpenMP threads for all Intel MKL functions on the current execution thread.
            </summary>
            <param name="nt">The number of threads for Intel MKL functions to use on the current execution thread.</param>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_get_max_threads">
            <summary>
            Gets the number of OpenMP threads targeted for parallelism.
            </summary>
            <returns>The maximum number of threads for Intel MKL functions to use in internal parallel regions.</returns>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_cbwr_set(System.Int32)">
            <summary>
            Configures the CNR mode of Intel MKL.
            </summary>
            <param name="setting">CNR branch to set.</param>
        </member>
        <member name="M:CSparse.Interop.MKL.NativeMethods.mkl_cbwr_get(System.Int32)">
            <summary>
            Returns the current CNR settings.
            </summary>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.MKL.SparseStatus">
            <summary>
            status of the routines
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.Success">
            <summary>
            the operation was successful
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.NotInitialized">
            <summary>
            empty handle or matrix arrays
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.AllocFailed">
            <summary>
            internal error: memory allocation failed
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.InvalidValue">
            <summary>
            invalid input value
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.ExecutionFailed">
            <summary>
            e.g. 0-diagonal element for triangular solver, etc.
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.InternalError">
            <summary>
            internal error
            </summary>
        </member>
        <member name="F:CSparse.Interop.MKL.SparseStatus.NotSupported">
            <summary>
            operation for double precision doesn't support other types
            </summary>
        </member>
        <member name="T:CSparse.Interop.MKL.SparseMatrixType">
            <summary>
            supported matrix types
            </summary>
        </member>
        <member name="T:CSparse.Interop.MKL.SparseIndexBase">
            <summary>
            sparse matrix indexing: C-style or Fortran-style
            </summary>
        </member>
        <member name="T:CSparse.Interop.MKL.SparseFillMode">
            <summary>
            applies to triangular matrices only ( SYMMETRIC, HERMITIAN, TRIANGULAR )
            </summary>
        </member>
        <member name="T:CSparse.Interop.MKL.SparseDiagType">
            <summary>
            applies to triangular matrices only ( SYMMETRIC, HERMITIAN, TRIANGULAR )
            </summary>
        </member>
        <member name="T:CSparse.Interop.Pardiso.PardisoContext`1">
            <summary>
            PARDISO context wrapping native factorization.
            </summary>
            <remarks>
            For symmetric (or Hermitian) problems, PARDISO expects the upper part of the matrix in CSR format.
            Since CSparse uses CSC format, make sure to pass in the lower part of the matrix.
            </remarks>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoContext`1.Options">
            <summary>
            Gets the PARDISO options.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Pardiso.PardisoContext`1"/> class.
            </summary>
            <param name="matrix">The matrix to factorize.</param>
            <param name="mtype">The matrix type (see constants in <see cref="T:CSparse.Interop.Pardiso.PardisoMatrixType"/>)</param>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.Factorize">
            <summary>
            Factorizes the matrix associated to this PARDISO instance.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.Solve(`0[],`0[])">
            <summary>
            Solves a system of linear equations, Ax = b.
            </summary>
            <param name="input">Right hand side vector b.</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.SolveTranspose(`0[],`0[])">
            <summary>
            Solves the transpose system of linear equations, A'x = b.
            </summary>
            <param name="input">Right hand side vector b</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.Solve(CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solves a system of linear equations for multiple right-hand sides, AX = B.
            </summary>
            <param name="input">Right hand side matrix B.</param>
            <param name="result">Solution matrix X.</param>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.Solve(System.Int32,CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solves a system of linear equations for multiple right-hand sides, AX = B.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right hand side matrix B.</param>
            <param name="result">Solution matrix X.</param>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.Solve(System.Int32,`0[],`0[])">
            <summary>
            Solves a system of linear equations, Ax = b.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right hand side vector b.</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.DoInitialize">
            <summary>
            Do initialization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.DoSymbolic">
            <summary>
            Do symbolic factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.DoNumeric">
            <summary>
            Do numeric factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.DoFactorize">
            <summary>
            Do symbolic and numeric factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoContext`1.DoSolve(System.Int32,CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve system of linear equations.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right-hand side b.</param>
            <param name="result">The solution x.</param>
            <returns></returns>
            <remarks>
            Parameter sys corresponds to iparm[11]:
               sys = 0: non-transposed
               sys = 1: conjugate transposed
               sys = 2: transposed
            </remarks>
        </member>
        <member name="T:CSparse.Interop.Pardiso.PardisoMatrixType">
            <summary>
            PARDISO matrix type.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.RealStructurallySymmetric">
            <summary>
            Real and structurally symmetric matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.RealSymmetricPositiveDefinite">
            <summary>
            Real and symmetric positive definite matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.RealSymmetricIndefinite">
            <summary>
            Real and symmetric indefinite matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.ComplexStructurallySymmetric">
            <summary>
            Complex and structurally symmetric matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.ComplexHermitianPositiveDefinite">
            <summary>
            Complex and Hermitian positive definite matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.ComplexHermitianIndefinite">
            <summary>
            Complex and Hermitian indefinite matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.ComplexSymmetric">
            <summary>
            Complex and symmetric matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.RealNonsymmetric">
            <summary>
            Real and nonsymmetric matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoMatrixType.ComplexNonsymmetric">
            <summary>
            Complex and nonsymmetric matrix.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Pardiso.PardisoOptions">
            <summary>
            PARDISO options.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.ColumnOrderingMethod">
            <summary>
            The method used to permute the columns of the input matrix. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.IterativeRefinement">
            <summary>
            The iterative refinement option.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.PivotingPerturbation">
            <summary>
            The threshold used for a diagonal entry to be an acceptable pivot. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.Scaling">
            <summary>
            Specifies whether input matrix A should be scaled. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.Transpose">
            <summary>
            The transpose mode option. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.WeightedMatching">
            <summary>
            Permute large elements close the diagonal. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.CheckMatrix">
            <summary>
            Check the sparse matrix representation for errors.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.SinglePrecision">
            <summary>
            Input arrays must be presented in single precision.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Pardiso.PardisoOptions.ZeroBasedIndexing">
            <summary>
            One- or zero-based indexing of columns and rows.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoOptions.iparm">
            <summary>
            The underlying Pardiso options array.
            </summary>
            <remarks>
            Having public access to this object is essential for a finer control
            over the factorization process. Make sure you understand all the options
            you are setting.
            
            See https://software.intel.com/en-us/mkl-developer-reference-c-pardiso-iparm-parameter and
                https://software.intel.com/en-us/articles/pardiso-parameter-table
            </remarks>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSparse.Interop.Pardiso.PardisoOptions"/> class.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Pardiso.PardisoOptions.SetDefault">
            <summary>
            Set default options (zero-based indexing, re-ordering using nested dissection, 2 steps of iterative refinement).
            </summary>
        </member>
        <member name="T:CSparse.Interop.Pardiso.PardisoOrdering">
            <summary>
            Column ordering method.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoOrdering.MinimumDegree">
            <summary>
            Minimum degree ordering.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoOrdering.NestedDissection">
            <summary>
            Nested dissection using METIS.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Pardiso.PardisoOrdering.ParallelNestedDissection">
            <summary>
            Parallel (OpenMP) version of the nested dissection algorithm.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C(System.Int32,System.Double,System.Int32,System.Int32,CSparse.Interop.Cholmod.CholmodSparse@,System.IntPtr,CSparse.Interop.Cholmod.CholmodDense@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.IntPtr@,CSparse.Interop.Cholmod.CholmodCommon@)" -->
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_QR(System.Int32,System.Double,System.Int32,CSparse.Interop.Cholmod.CholmodSparse@,System.IntPtr@,System.IntPtr@,System.IntPtr@,CSparse.Interop.Cholmod.CholmodCommon@)" -->
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_backslash(System.Int32,System.Double,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodCommon@)" -->
        <member name="M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_backslash_default(CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            X = A\B where B is dense, using default ordering and tol
            </summary>
            <param name="A">m-by-n sparse matrix</param>
            <param name="B">m-by-k</param>
            <param name="cc">workspace and parameters</param>
            <returns>returns X, NULL if failure</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_backslash_sparse(System.Int32,System.Double,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)" -->
        <!-- Badly formed XML comment ignored for member "M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_factorize(System.Int32,System.Double,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)" -->
        <member name="M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_symbolic(System.Int32,System.Int32,CSparse.Interop.Cholmod.CholmodSparse@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            Performs the symbolic factorization and returns a QR factorization object to be passed to
            SuiteSparseQR_numeric. It does not exploit singletons.
            </summary>
            <param name="ordering">all, except 3:given treated as 0:fixed</param>
            <param name="allow_tol">if TRUE allow tol for rank detection</param>
            <param name="A">m-by-n sparse matrix, A->x ignored</param>
            <param name="cc">workspace and parameters</param>
            <returns>SuiteSparseQR_C_factorization</returns>
        </member>
        <member name="M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_numeric(System.Double,CSparse.Interop.Cholmod.CholmodSparse@,System.IntPtr,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            Performs the numeric factorization on a QR factorization object, either one constructed
            by SuiteSparseQR_symbolic, or reusing one from a prior call to SuiteSparseQR_numeric for
            a matrix A with the same pattern as the first one, but with different numerical values.
            </summary>
            <param name="tol">treat columns with 2-norm &lt;= tol as zero</param>
            <param name="A">sparse matrix to factorize</param>
            <param name="QR">SuiteSparseQR_C_factorization</param>
            <param name="cc">workspace and parameters</param>
            <returns>returns TRUE (1) if successful, FALSE (0) otherwise</returns>
        </member>
        <member name="M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_free(System.IntPtr@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            Free the QR factors computed by SuiteSparseQR_C_factorize
            </summary>
            <param name="QR">SuiteSparseQR_C_factorization</param>
            <param name="cc">workspace and parameters</param>
            <returns>returns TRUE (1) if OK, FALSE (0) otherwise</returns>
        </member>
        <member name="M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_solve(System.Int32,System.IntPtr,System.IntPtr,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            Solves a linear system using the QR object.
            </summary>
            <param name="system">which system to solve</param>
            <param name="QR">SuiteSparseQR_C_factorization</param>
            <param name="B">right-hand-side, m-by-k or n-by-k</param>
            <param name="cc">workspace and parameters</param>
            <returns>return CholmodDense pointer X, or NULL if failure</returns>
            <remarks>
            system SPQR_RX_EQUALS_B    (0): X = R\B         B is m-by-k and X is n-by-k
            system SPQR_RETX_EQUALS_B  (1): X = E*(R\B)     as above, E is a permutation
            system SPQR_RTX_EQUALS_B   (2): X = R'\B        B is n-by-k and X is m-by-k
            system SPQR_RTX_EQUALS_ETB (3): X = R'\(E'*B)   as above, E is a permutation
            </remarks>
        </member>
        <member name="M:CSparse.Interop.SPQR.NativeMethods.SuiteSparseQR_C_qmult(System.Int32,System.IntPtr,CSparse.Interop.Cholmod.CholmodDense@,CSparse.Interop.Cholmod.CholmodCommon@)">
            <summary>
            Applies Q in Householder form (as stored in the QR factorization object
            returned by SuiteSparseQR_C_factorize) to a dense matrix X.
            </summary>
            <param name="method">0,1,2,3</param>
            <param name="QR">SuiteSparseQR_C_factorization</param>
            <param name="X">cholmod_dense size m-by-n with leading dimension ldx</param>
            <param name="cc">workspace and parameters</param>
            <returns>return CholmodDense pointer X, or NULL if failure</returns>
            <remarks>
            method SPQR_QTX (0): Y = Q'*X
            method SPQR_QX  (1): Y = Q*X
            method SPQR_XQT (2): Y = X*Q'
            method SPQR_XQ  (3): Y = X*Q
            </remarks>
        </member>
        <member name="T:CSparse.Interop.SPQR.SpqrContext`1">
            <summary>
            SPQR context wrapping native factorization.
            </summary>
        </member>
        <member name="M:CSparse.Interop.SPQR.SpqrContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initializes a new instance of the SpqrContext class.
            </summary>
            <param name="matrix">The sparse matrix to factorize.</param>
        </member>
        <member name="M:CSparse.Interop.SPQR.SpqrContext`1.CopyDense(CSparse.Interop.Cholmod.CholmodDense,CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Copy native memory to dense matrix.
            </summary>
            <param name="dense">CHOLMOD dense matrix.</param>
            <param name="matrix">Target storage.</param>
        </member>
        <member name="M:CSparse.Interop.SPQR.SpqrContext`1.CreateDense(CSparse.Storage.DenseColumnMajorStorage{`0},System.Collections.Generic.List{System.Runtime.InteropServices.GCHandle})">
            <summary>
            Create CHOLMOD dense matrix from managed type.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="handles">List of handles.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.SPQR.SpqrContext`1.CreateSparse(CSparse.Storage.CompressedColumnStorage{`0},System.Collections.Generic.List{System.Runtime.InteropServices.GCHandle})">
            <summary>
            Create CHOLMOD sparse matrix from managed type.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="handles">List of handles.</param>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.SPQR.SpqrOrdering">
            <summary>
            Ordering method to use.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.Fixed">
            <summary>
            Fixed ordering.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.Natural">
            <summary>
            Use natural ordering.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.COLAMD">
            <summary>
            Use COLAMD.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.Given">
            <summary>
            Use given permutation.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.CHOLMOD">
            <summary>
            Use CHOLMOD best-effort (COLAMD, METIS, ...).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.AMD">
            <summary>
            Use minimum degree AMD(A'*A).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.METIS">
            <summary>
            Use METIS(A'*A) nested dissection.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.Default">
            <summary>
            Use SuiteSparseQR default ordering.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.Best">
            <summary>
            Try COLAMD/AMD/METIS and use best.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SPQR.SpqrOrdering.BestAMD">
            <summary>
            Try COLAMD/AMD and use best.
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.OrderingMethod">
            <summary>
            Column ordering method.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.OrderingMethod.Natural">
            <summary>
            Natural ordering.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.OrderingMethod.MinimumDegreeAtA">
            <summary>
            Minimum degree ordering on the structure of A^TA.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.OrderingMethod.MinimumDegreeAtPlusA">
            <summary>
            Minimum degree ordering on the structure of A^T+A.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.OrderingMethod.ColumnApproximateMinimumDegree">
            <summary>
            Column approximate minimum degree ordering.
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.SuperLUContext`1">
            <summary>
            SuperLU context wrapping native factorization.
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUContext`1.Options">
            <summary>
            Gets the SuperLU options.
            </summary>
        </member>
        <member name="M:CSparse.Interop.SuperLU.SuperLUContext`1.Factorize">
            <summary>
            Factorizes the matrix associated to this UMFPACK instance.
            </summary>
        </member>
        <member name="M:CSparse.Interop.SuperLU.SuperLUContext`1.Solve(`0[],`0[])">
            <summary>
            Solves a system of linear equations, Ax = b.
            </summary>
            <param name="input">Right hand side vector b.</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.SuperLU.SuperLUContext`1.Solve(CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solves a system of linear equations for multiple right-hand sides, AX = B.
            </summary>
            <param name="input">Right hand side matrix B.</param>
            <param name="result">Solution matrix X.</param>
        </member>
        <member name="M:CSparse.Interop.SuperLU.SuperLUContext`1.CreateArray(System.Int32)">
            <summary>
            Create single or double-precision floating point arrays.
            </summary>
            <param name="size">The array size.</param>
            <remarks>
            At the moment, only double-precision is implemented.
            </remarks>
        </member>
        <member name="M:CSparse.Interop.SuperLU.SuperLUContext`1.DoFactorize">
            <summary>
            Do symbolic and numeric factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.SuperLU.SuperLUContext`1.DoSolve(CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solve system of linear equations.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right-hand side b.</param>
            <param name="result">The solution x.</param>
            <returns></returns>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.ColumnOrderingMethod">
            <summary>
            The method used to permute the columns of the input matrix. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.ConditionNumber">
            <summary>
            Specifies whether to compute an estimate of the reciprocal condition number of the matrix A. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.DiagonalPivotThreshold">
            <summary>
            The threshold used for a diagonal entry to be an acceptable pivot. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.Equilibrate">
            <summary>
            Specifies if input matrix A is equilibrated before factorization. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.IterativeRefinement">
            <summary>
            The iterative refinement option.
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.PivotGrowth">
            <summary>
            Specifies whether to compute the reciprocal pivot growth factor. 
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.SymmetricMode">
            <summary>
            The symmetric mode option.
            </summary>
        </member>
        <member name="P:CSparse.Interop.SuperLU.SuperLUOptions.Transpose">
            <summary>
            The transpose mode option. 
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperLUOptions.Raw">
            <summary>
            Returns the underlying SuperLU options structure. 
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.superlu_options">
            <summary>
            Options used to control the solution process
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.Fact">
            <summary>
            Specifies whether or not the factored form of the matrix A is supplied on entry (fact_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.Equil">
            <summary>
            Specifies whether to equilibrate the system (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ColPerm">
            <summary>
            Specifies what type of column permutation to use to reduce fill (colperm_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.Trans">
            <summary>
            Specifies the form of the system of equations (trans_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.IterRefine">
            <summary>
            Specifies whether to perform iterative refinement (IterRefine_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.DiagPivotThresh">
            <summary>
            Specifies the threshold used for a diagonal entry to be an acceptable pivot.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.SymmetricMode">
            <summary>
            Specifies whether to use symmetric mode (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.PivotGrowth">
            <summary>
            Specifies whether to compute the reciprocal pivot growth (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ConditionNumber">
            <summary>
            Specifies whether to compute the reciprocal condition number (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.RowPerm">
            <summary>
            Specifies whether to permute rows of the original matrix (rowperm_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_DropRule">
            <summary>
            Specifies the dropping rule
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_DropTol">
            <summary>
            numerical threshold for dropping
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_FillFactor">
            <summary>
            gamma in the secondary dropping
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_Norm">
            <summary>
            Specify which norm to use to measure the row size in a supernode (norm_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_FillTol">
            <summary>
            numerical threshold for zero pivot perturbation
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_MILU">
            <summary>
            Specifies which version of MILU to use (milu_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ILU_MILU_Dim">
            <summary>
            Dimension of PDE (if available)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ParSymbFact">
            <summary>
            used in SuperLU_DIST(yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.ReplaceTinyPivot">
            <summary>
            Specifies whether to replace the tiny diagonals by sqrt(epsilon)*||A||
            during LU factorization (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.SolveInitialized">
            <summary>
            Specifies whether the initialization has been performed to the triangular solve (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.RefineInitialized">
            <summary>
            Specifies whether the initialization has been performed to the sparse
            matrix-vector multiplication routine needed in iterative refinement (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.PrintStat">
            <summary>
            Specifies whether to print the solver's statistics (yes_no_t).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.nnzL">
            <summary>
            used to store nnzs for now
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.nnzU">
            <summary>
            used to store nnzs for now
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.num_lookaheads">
            <summary>
            num of levels in look-ahead
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.lookahead_etree">
            <summary>
            use etree computed from the serial symbolic factorization (yes_no_t)
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.superlu_options.SymPattern">
            <summary>
            symmetric factorization (yes_no_t)
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.Stype">
            <summary>
            Storage type.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_NC">
            <summary>
            Column-wise, no supernode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_NCP">
            <summary>
            Column-wise, column-permuted, no supernode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_NR">
            <summary>
            Row-wise, no supernode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_SC">
            <summary>
            Column-wise, supernode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_SCP">
            <summary>
            Supernode, column-wise, permuted.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_SR">
            <summary>
            Row-wise, supernode.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_DN">
            <summary>
            Fortran style column-wise storage for dense matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Stype.SLU_NR_loc">
            <summary>
            Distributed compressed row format.
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.Dtype">
            <summary>
            Data type.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Dtype.SLU_S">
            <summary>
            Single precision.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Dtype.SLU_D">
            <summary>
            Double precision.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Dtype.SLU_C">
            <summary>
            Single precision complex.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Dtype.SLU_Z">
            <summary>
            Double precision complex.
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.Mtype">
            <summary>
            Mathematical type.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_GE">
            <summary>
            General.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_TRLU">
            <summary>
            Lower triangular, unit diagonal.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_TRUU">
            <summary>
            Upper triangular, unit diagonal.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_TRL">
            <summary>
            Lower triangular.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_TRU">
            <summary>
            Upper triangular.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_SYL">
            <summary>
            Symmetric, store lower half.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_SYU">
            <summary>
            Symmetric, store upper half.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_HEL">
            <summary>
            Hermitian, store lower half.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.Mtype.SLU_HEU">
            <summary>
            Hermitian, store upper half.
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.NCformat">
            <summary>
            Stype == SLU_NC (Also known as Harwell-Boeing sparse matrix format).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NCformat.nnz">
            <summary>
            Number of nonzeros in the matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NCformat.nzval">
            <summary>
            Pointer to array of nonzero values, packed by column.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NCformat.rowind">
            <summary>
            Pointer to array of row indices of the nonzeros.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NCformat.colptr">
            <summary>
            Pointer to array of beginning of columns in nzval[] and rowind[].
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.NRformat">
            <summary>
            Stype == SLU_NR (compressed sparse row format).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NRformat.nnz">
            <summary>
            Number of nonzeros in the matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NRformat.nzval">
            <summary>
            Pointer to array of nonzero values, packed by row.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NRformat.colind">
            <summary>
            Pointer to array of columns indices of the nonzeros.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.NRformat.rowptr">
            <summary>
            Pointer to array of beginning of rows in nzval[] and colind[].
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.SCformat">
            <summary>
            Stype == SLU_SC (column-wise, supernode).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.nnz">
            <summary>
            Number of nonzeros in the matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.nsuper">
            <summary>
            Number of supernodes (minus 1).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.nzval">
            <summary>
            Pointer to array of nonzero values, packed by column.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.nzval_colptr">
            <summary>
            Pointer to array of beginning of columns in nzval[].
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.rowind">
            <summary>
            Pointer to array of compressed row indices of rectangular supernodes.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.rowind_colptr">
            <summary>
            Pointer to array of beginning of columns in rowind[].
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.col_to_sup">
            <summary>
            col_to_sup[j] is the supernode number to which column j belongs
            (mapping from column to supernode number).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SCformat.sup_to_col">
            <summary>
            sup_to_col[s] points to the start of the s-th supernode
            (mapping from supernode number to column).
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.DNformat">
            <summary>
            Stype == SLU_DN (dense matrix).
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.DNformat.lda">
            <summary>
            Leading dimension.
            </summary>
            <remarks>
            Assuming the Fortran column-major ordering, the LDA is used to define the
            distance in memory between elements of two consecutive columns which have
            the same row index.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.SuperLU.DNformat.nzval">
            <summary>
            Array of size lda*ncol to represent a dense matrix.
            </summary>
        </member>
        <member name="T:CSparse.Interop.SuperLU.SuperMatrix">
            <summary>
            SuperMatrix struct.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperMatrix.Stype">
            <summary>
            Storage type: interprets the storage structure pointed to by Store.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperMatrix.Dtype">
            <summary>
            Data type.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperMatrix.Mtype">
            <summary>
            Matrix type: describes the mathematical property of the matrix.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperMatrix.nrow">
            <summary>
            Number of rows.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperMatrix.ncol">
            <summary>
            Number of columns.
            </summary>
        </member>
        <member name="F:CSparse.Interop.SuperLU.SuperMatrix.Store">
            <summary>
            Pointer to the actual storage of the matrix.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_col_to_triplet(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Converts a column-oriented matrix to a triplet form.
            </summary>
            <param name="n_col">Number of columns (A is an n_row-by-n_col matrix.  Restriction: n_col > 0.).</param>
            <param name="Ap">The column pointers of the column-oriented form of the matrix.</param>
            <param name="Tj">Integer array of size nz on input, where nz = Ap [n_col].</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_defaults(System.Double[])">
            <summary>
            Sets the default control parameter settings.
            </summary>
            <param name="Control">Control is set to the default control parameter settings.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_free_numeric(System.IntPtr@)">
            <summary>
            Deallocates the Numeric object and sets the Numeric handle to NULL. This
            routine is the only valid way of destroying the Numeric object.
            </summary>
            <param name="Numeric">Numeric points to a valid Numeric object, computed by umfpack_*_numeric.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_free_symbolic(System.IntPtr@)">
            <summary>
            Deallocates the Symbolic object and sets the Symbolic handle to NULL. This
            routine is the only valid way of destroying the Symbolic object.
            </summary>
            <param name="Symbolic">Points to a valid Symbolic object computed by umfpack_*_symbolic.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_get_determinant(System.Double[],System.Double[],System.IntPtr,System.Double[])">
            <summary>
            Using the LU factors and the permutation vectors contained in the Numeric
            object, calculate the determinant of the matrix A.
            </summary>
            <param name="Mx">Array of size 1.</param>
            <param name="Ex">Array of size 1 (optional).</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <param name="Info">Contains information about the calculation of the determinant.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_get_lunz(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.IntPtr)">
            <summary>
            Determines the size and number of nonzeros in the LU factors held by the Numeric object.
            </summary>
            <param name="lnz">The number of nonzeros in L, including the diagonal (which is all one's).</param>
            <param name="unz">The number of nonzeros in U, including the diagonal.</param>
            <param name="n_row"></param>
            <param name="n_col"></param>
            <param name="nz_udiag">The number of numerically nonzero values on the diagonal of U.</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <returns>UMFPACK status code.</returns>
            <remarks>
            These are also the sizes of the output arrays required by umfpack_*_get_numeric.
            
            The matrix L is n_row -by- min(n_row,n_col), with lnz nonzeros, including
            the entries on the unit diagonal of L.
            
            The matrix U is min(n_row,n_col) -by- n_col, with unz nonzeros, including
            nonzeros on the diagonal of U.
            
            The matrix is singular if nz_diag &lt; min(n_row,n_col). A divide-by-zero
            will occur if nz_diag &lt; n_row == n_col when solving a sparse system
            involving the matrix U in umfpack_*_*solve.
            </remarks>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_get_numeric(System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],System.Double[],System.Int32@,System.Double[],System.IntPtr)">
            <summary>
            This routine copies the LU factors and permutation vectors from the Numeric
            object into user-accessible arrays.
            </summary>
            <param name="Lp">Lp [n_row+1]</param>
            <param name="Lj">Lj [lnz]</param>
            <param name="Lx">Lx [lnz]</param>
            <param name="Up">Up [n_col+1]</param>
            <param name="Ui">Ui [unz]</param>
            <param name="Ux">Ux [unz]</param>
            <param name="P">The permutation vector P is defined as P [k] = i, where the original row i of A is the kth pivot row in PAQ</param>
            <param name="Q">The permutation vector Q is defined as Q [k] = j, where the original column j of A is the kth pivot column in PAQ.</param>
            <param name="Dx">The diagonal of U is also returned in Dx.</param>
            <param name="do_recip">This argument defines how the scale factors Rs are to be interpretted.</param>
            <param name="Rs">The row scale factors are returned in Rs [0..n_row-1].</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_get_symbolic(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.IntPtr)">
            <summary>
            Copies the contents of the Symbolic object into simple integer arrays accessible to the user.
            </summary>
            <param name="n_row"></param>
            <param name="n_col"></param>
            <param name="n1">The number of pivots with zero Markowitz cost.</param>
            <param name="nz">The number of nonzeros in A.</param>
            <param name="nfr">The number of frontal matrices that will be used to factorize the matrix A.</param>
            <param name="nchains"></param>
            <param name="P">The initial row permutation P [n_row].</param>
            <param name="Q">The initial column permutation Q [n_col].</param>
            <param name="Front_npivcol">Front_npivcol [n_col+1]</param>
            <param name="Front_parent">Front_parent [n_col+1]</param>
            <param name="Front_1strow">Front_1strow [n_col+1]</param>
            <param name="Front_leftmostdesc">Front_leftmostdesc [n_col+1]</param>
            <param name="Chain_start">Chain_start [n_col+1]</param>
            <param name="Chain_maxrows">Chain_maxrows [n_col+1]</param>
            <param name="Chain_maxcols">Chain_maxcols [n_col+1]</param>
            <param name="Symbolic">The Symbolic object, which holds the symbolic factorization.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_load_numeric(System.IntPtr@,System.String)">
            <summary>
            Loads a Numeric object from a file created by umfpack_*_save_numeric.
            </summary>
            <param name="Numeric">On output, this variable holds a pointer to the Numeric
            object (if successful), or NULL if a failure occurred.</param>
            <param name="filename">A string that contains the filename from which to read the Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_load_symbolic(System.IntPtr@,System.String)">
            <summary>
            Loads a Symbolic object from a file created by umfpack_*_save_symbolic.
            </summary>
            <param name="Symbolic">On output, this variable holds a pointer to the Symbolic
            object (if successful), or NULL if a failure occurred.</param>
            <param name="filename">A string that contains the filename from which to read the Symbolic object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_numeric(System.Int32[],System.Int32[],System.Double[],System.IntPtr,System.IntPtr@,System.Double[],System.Double[])">
            <summary>
            Given a sparse matrix A in column-oriented form, and a symbolic analysis
            computed by umfpack_*_*symbolic, the umfpack_*_numeric routine performs the
            numerical factorization
            </summary>
            <param name="Ap">This must be identical to the Ap array passed to umfpack_*_*symbolic.</param>
            <param name="Ai">This must be identical to the Ai array passed to umfpack_*_*symbolic.</param>
            <param name="Ax">The numerical values of the sparse matrix A.</param>
            <param name="Symbolic">The Symbolic object, which holds the symbolic factorization
            computed by umfpack_*_*symbolic.</param>
            <param name="Numeric">On output, this variable holds a pointer to the Numeric
            object (if successful), or NULL if a failure occurred.</param>
            <param name="Control">If a NULL pointer is passed, then the default control
            settings are used.  Otherwise, the settings are determined from the Control array.</param>
            <param name="Info"></param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_qsymbolic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.IntPtr@,System.Double[],System.Double[])">
             <summary>
             Given the nonzero pattern of a sparse matrix A in column-oriented form, and
             a sparsity preserving column pre-ordering Q, umfpack_*_qsymbolic performs
             the symbolic factorization of A*Q.
             </summary>
             <param name="n_row"></param>
             <param name="n_col"></param>
             <param name="Ap"></param>
             <param name="Ai"></param>
             <param name="Ax"></param>
             <param name="Qinit">The user's fill-reducing initial column pre-ordering.</param>
             <param name="Symbolic"></param>
             <param name="Control"></param>
             <param name="Info"></param>
             <returns>UMFPACK status code.</returns>
             <remarks>
             This is identical to umfpack_*_symbolic, except that neither
             COLAMD nor AMD are called and the user input column order Qinit is used
             instead.  Note that in general, the Qinit passed to umfpack_*_qsymbolic
             can differ from the final Q found in umfpack_*_numeric.  The unsymmetric
             strategy will perform a column etree postordering done in
             umfpack_*_qsymbolic and sparsity-preserving modifications are made within
             each frontal matrix during umfpack_*_numeric.  The symmetric
             strategy will preserve Qinit, unless the matrix is structurally singular.
            
             *** WARNING ***  A poor choice of Qinit can easily cause umfpack_*_numeric
             to use a huge amount of memory and do a lot of work.  The "default" symbolic
             analysis method is umfpack_*_symbolic, not this routine.  If you use this
             routine, the performance of UMFPACK is your responsibility;  UMFPACK will
             not try to second-guess a poor choice of Qinit.
             </remarks>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_save_numeric(System.IntPtr,System.String)">
            <summary>
            Saves a Numeric object to a file, which can later be read by
            umfpack_*_load_numeric.  The Numeric object is not modified.
            </summary>
            <param name="Numeric">Numeric must point to a valid Numeric object</param>
            <param name="filename">A string that contains the filename to which the Numeric object is written.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_save_symbolic(System.IntPtr,System.String)">
            <summary>
            Saves a Symbolic object to a file, which can later be read by
            umfpack_*_load_symbolic.  The Symbolic object is not modified.
            </summary>
            <param name="Symbolic">Symbolic must point to a valid Symbolic object.</param>
            <param name="filename">A string that contains the filename to which the Symbolic object is written.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_scale(System.Double[],System.Double[],System.IntPtr)">
            <summary>
            Given LU factors computed by umfpack_*_numeric (PAQ=LU, PRAQ=LU, or
            P(R\A)Q=LU), and a vector B, this routine computes X = B, X = R*B, or
            X = R\B, as appropriate.  X and B must be vectors equal in length to the
            number of rows of A.
            </summary>
            <param name="X">The output vector X [n_row].</param>
            <param name="B">The input vector B [n_row].</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_solve(System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Double[],System.IntPtr,System.Double[],System.Double[])">
             <summary>
             Given LU factors computed by umfpack_*_numeric (PAQ=LU, PRAQ=LU, or
             P(R\A)Q=LU) and the right-hand-side, B, solve a linear system for the
             solution X.  Iterative refinement is optionally performed.
             </summary>
             <param name="sys">Defines which system to solve.</param>
             <param name="Ap">Ap [n+1]</param>
             <param name="Ai">Ai [nz]</param>
             <param name="Ax">Ax [nz]</param>
             <param name="X">X [n] The solution to the linear system, where n = n_row = n_col is the dimension of the matrices A, L, and U.</param>
             <param name="B">B [n] The right-hand side vector.</param>
             <param name="Numeric">Numeric must point to a valid Numeric object</param>
             <param name="Control"></param>
             <param name="Info"></param>
             <returns>UMFPACK status code.</returns>
             <remarks>
             Only square systems are handled. Singular matrices result in a divide-by-zero for all
             systems except those involving just the matrix L.  Iterative refinement is not performed
             for singular matrices. In the discussion below, n is equal to n_row and n_col, because
             only square systems are handled.
             
             
             The sys paramater defines which system to solve.  (') is the linear algebraic transpose
             (complex conjugate if A is complex), and (.') is the array transpose.
            
                 sys value	    system solved
                 UMFPACK_A       Ax=b
                 UMFPACK_At      A'x=b
                 UMFPACK_Aat     A.'x=b
                 UMFPACK_Pt_L    P'Lx=b
                 UMFPACK_L       Lx=b
                 UMFPACK_Lt_P    L'Px=b
                 UMFPACK_Lat_P   L.'Px=b
                 UMFPACK_Lt      L'x=b
                 UMFPACK_U_Qt    UQ'x=b
                 UMFPACK_U       Ux=b
                 UMFPACK_Q_Ut    QU'x=b
                 UMFPACK_Q_Uat   QU.'x=b
                 UMFPACK_Ut      U'x=b
                 UMFPACK_Uat     U.'x=b
            
             Iterative refinement can be optionally performed when sys is any of
             the following:
            
                 UMFPACK_A       Ax=b
                 UMFPACK_At      A'x=b
                 UMFPACK_Aat     A.'x=b
            
             For the other values of the sys argument, iterative refinement is not
             performed (Control [UMFPACK_IRSTEP], Ap, Ai, Ax, and Az are ignored).
             </remarks>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_symbolic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.IntPtr@,System.Double[],System.Double[])">
            <summary>
            Given nonzero pattern of a sparse matrix A in column-oriented form,
            umfpack_*_symbolic performs a column pre-ordering to reduce fill-in
            (using COLAMD, AMD or METIS) and a symbolic factorization.
            </summary>
            <param name="n_row">A is an n_row-by-n_col matrix.</param>
            <param name="n_col">A is an n_row-by-n_col matrix.</param>
            <param name="Ap">Ap is an integer array of size n_col+1.</param>
            <param name="Ai">The row indices Ai [nz].</param>
            <param name="Ax">The numerical values Ax [nz].</param>
            <param name="Symbolic">On output, this variable holds a pointer to the Symbolic
            object (if successful), or NULL if a failure occurred.</param>
            <param name="Control"></param>
            <param name="Info"></param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_transpose(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Double[])">
            <summary>
            Transposes and optionally permutes a sparse matrix in row or column-form, R = (PAQ)'.
            </summary>
            <param name="n_row">A is an n_row-by-n_col matrix.</param>
            <param name="n_col">A is an n_row-by-n_col matrix.</param>
            <param name="Ap">Ap [n_col+1] The column pointers of the column-oriented form of the matrix A.</param>
            <param name="Ai">The row indices Ai [nz].</param>
            <param name="Ax">If present, these are the numerical values of the sparse matrix A.</param>
            <param name="P">The row permutation vector P [n_row] (optional).</param>
            <param name="Q">The column permutation vector Q [n_col] (optional).</param>
            <param name="Rp">The column pointers of the matrix R.</param>
            <param name="Ri">The row indices of the matrix R.</param>
            <param name="Rx">If present, these are the numerical values of the sparse matrix R.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_triplet_to_col(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],System.Double[],System.Int32[])">
            <summary>
            Converts a sparse matrix from "triplet" form to compressed-column form.
            </summary>
            <param name="n_row">A is an n_row-by-n_col matrix.</param>
            <param name="n_col">A is an n_row-by-n_col matrix.</param>
            <param name="nz">The number of entries in the triplet form of the matrix.</param>
            <param name="Ti">The row indices of the "triplet" form of a sparse matrix.</param>
            <param name="Tj">The column indices of the "triplet" form of a sparse matrix.</param>
            <param name="Tx">The values of the "triplet" form of a sparse matrix.</param>
            <param name="Ap">Array of size n_col+1. On output, Ap holds the "pointers" for
            the column form of the sparse matrix A.</param>
            <param name="Ai">Array of size nz. Note that only the first Ap [n_col] entries are used.</param>
            <param name="Ax">Array of size nz. Note that only the first Ap [n_col] entries are used (optional).</param>
            <param name="Map">Array of size nz. If present, then on output it holds the position of the triplets in the column-form matrix.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_di_wsolve(System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Double[],System.IntPtr,System.Double[],System.Double[],System.Int32[],System.Double[])">
             <summary>
             Given LU factors computed by umfpack_*_numeric (PAQ=LU) and the
             right-hand-side, B, solve a linear system for the solution X.  Iterative
             refinement is optionally performed.
             </summary>
             <param name="sys"></param>
             <param name="Ap"></param>
             <param name="Ai"></param>
             <param name="Ax"></param>
             <param name="X"></param>
             <param name="B"></param>
             <param name="Numeric"></param>
             <param name="Control"></param>
             <param name="Info"></param>
             <param name="Wi">Workspace size n.</param>
             <param name="W">Workspace size c*n, where c is defined below.</param>
             <returns>UMFPACK status code.</returns>
             <remarks>
             This routine is identical to umfpack_*_solve, except that it does not dynamically
             allocate any workspace. When you have many linear systems to solve, this routine is
             faster than umfpack_*_solve, since the workspace (Wi, W) needs to be allocated only
             once, prior to calling umfpack_*_wsolve.
             The size of W is given as:
            
                            no iter.	with iter.
                            refinement	refinement
                real     	n		5*n
                complex  	4*n		10*n
             </remarks>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_col_to_triplet(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Converts a column-oriented matrix to a triplet form.
            </summary>
            <param name="n_col">Number of columns (A is an n_row-by-n_col matrix.  Restriction: n_col > 0.).</param>
            <param name="Ap">The column pointers of the column-oriented form of the matrix.</param>
            <param name="Tj">Integer array of size nz on input, where nz = Ap [n_col].</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_defaults(System.Double[])">
            <summary>
            Sets the default control parameter settings.
            </summary>
            <param name="Control">Control is set to the default control parameter settings.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_free_numeric(System.IntPtr@)">
            <summary>
            Deallocates the Numeric object and sets the Numeric handle to NULL. This
            routine is the only valid way of destroying the Numeric object.
            </summary>
            <param name="Numeric">Numeric points to a valid Numeric object, computed by umfpack_*_numeric.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_free_symbolic(System.IntPtr@)">
            <summary>
            Deallocates the Symbolic object and sets the Symbolic handle to NULL. This
            routine is the only valid way of destroying the Symbolic object.
            </summary>
            <param name="Symbolic">Points to a valid Symbolic object computed by umfpack_*_symbolic.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_get_determinant(System.Double[],System.Double[],System.Double[],System.IntPtr,System.Double[])">
            <summary>
            Using the LU factors and the permutation vectors contained in the Numeric
            object, calculate the determinant of the matrix A.
            </summary>
            <param name="Mx">Array of size 1 or 2.</param>
            <param name="Mz">Array of size 1 (optional).</param>
            <param name="Ex">Array of size 1 (optional).</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <param name="Info">Contains information about the calculation of the determinant.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_get_lunz(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.IntPtr)">
            <summary>
            Determines the size and number of nonzeros in the LU factors held by the Numeric object.
            </summary>
            <param name="lnz">The number of nonzeros in L, including the diagonal (which is all one's).</param>
            <param name="unz">The number of nonzeros in U, including the diagonal.</param>
            <param name="n_row"></param>
            <param name="n_col"></param>
            <param name="nz_udiag">The number of numerically nonzero values on the diagonal of U.</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_get_numeric(System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32@,System.Double[],System.IntPtr)">
            <summary>
            This routine copies the LU factors and permutation vectors from the Numeric
            object into user-accessible arrays.
            </summary>
            <param name="Lp">Lp [n_row+1]</param>
            <param name="Lj">Lj [lnz]</param>
            <param name="Lx">Lx [lnz]</param>
            <param name="Lz"></param>
            <param name="Up">Up [n_col+1]</param>
            <param name="Ui">Ui [unz]</param>
            <param name="Ux">Ux [unz]</param>
            <param name="Uz"></param>
            <param name="P">The permutation vector P is defined as P [k] = i, where the original row i of A is the kth pivot row in PAQ</param>
            <param name="Q">The permutation vector Q is defined as Q [k] = j, where the original column j of A is the kth pivot column in PAQ.</param>
            <param name="Dx">The diagonal of U is also returned in Dx.</param>
            <param name="Dz"></param>
            <param name="do_recip">This argument defines how the scale factors Rs are to be interpretted.</param>
            <param name="Rs">The row scale factors are returned in Rs [0..n_row-1].</param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_get_symbolic(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.IntPtr)">
            <summary>
            Copies the contents of the Symbolic object into simple integer arrays accessible to the user.
            </summary>
            <param name="n_row"></param>
            <param name="n_col"></param>
            <param name="n1">The number of pivots with zero Markowitz cost.</param>
            <param name="nz">The number of nonzeros in A.</param>
            <param name="nfr">The number of frontal matrices that will be used to factorize the matrix A.</param>
            <param name="nchains"></param>
            <param name="P">The initial row permutation P [n_row].</param>
            <param name="Q">The initial column permutation Q [n_col].</param>
            <param name="Front_npivcol">Front_npivcol [n_col+1]</param>
            <param name="Front_parent">Front_parent [n_col+1]</param>
            <param name="Front_1strow">Front_1strow [n_col+1]</param>
            <param name="Front_leftmostdesc">Front_leftmostdesc [n_col+1]</param>
            <param name="Chain_start">Chain_start [n_col+1]</param>
            <param name="Chain_maxrows">Chain_maxrows [n_col+1]</param>
            <param name="Chain_maxcols">Chain_maxcols [n_col+1]</param>
            <param name="Symbolic">The Symbolic object, which holds the symbolic factorization.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_load_numeric(System.IntPtr@,System.String)">
            <summary>
            Loads a Numeric object from a file created by umfpack_*_save_numeric.
            </summary>
            <param name="Numeric">On output, this variable holds a pointer to the Numeric
            object (if successful), or NULL if a failure occurred.</param>
            <param name="filename">A string that contains the filename from which to read the Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_load_symbolic(System.IntPtr@,System.String)">
            <summary>
            Loads a Symbolic object from a file created by umfpack_*_save_symbolic.
            </summary>
            <param name="Symbolic">On output, this variable holds a pointer to the Symbolic
            object (if successful), or NULL if a failure occurred.</param>
            <param name="filename">A string that contains the filename from which to read the Symbolic object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_numeric(System.Int32[],System.Int32[],System.Double[],System.Double[],System.IntPtr,System.IntPtr@,System.Double[],System.Double[])">
            <summary>
            Given a sparse matrix A in column-oriented form, and a symbolic analysis
            computed by umfpack_*_*symbolic, the umfpack_*_numeric routine performs the
            numerical factorization
            </summary>
            <param name="Ap">This must be identical to the Ap array passed to umfpack_*_*symbolic.</param>
            <param name="Ai">This must be identical to the Ai array passed to umfpack_*_*symbolic.</param>
            <param name="Ax">The numerical values of the sparse matrix A.</param>
            <param name="Az"></param>
            <param name="Symbolic">The Symbolic object, which holds the symbolic factorization
            computed by umfpack_*_*symbolic.</param>
            <param name="Numeric">On output, this variable holds a pointer to the Numeric
            object (if successful), or NULL if a failure occurred.</param>
            <param name="Control">If a NULL pointer is passed, then the default control
            settings are used.  Otherwise, the settings are determined from the Control array.</param>
            <param name="Info"></param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_qsymbolic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32[],System.IntPtr@,System.Double[],System.Double[])">
            <summary>
            Given the nonzero pattern of a sparse matrix A in column-oriented form, and
            a sparsity preserving column pre-ordering Q, umfpack_*_qsymbolic performs
            the symbolic factorization of A*Q.
            </summary>
            <param name="n_row"></param>
            <param name="n_col"></param>
            <param name="Ap"></param>
            <param name="Ai"></param>
            <param name="Ax"></param>
            <param name="Az"></param>
            <param name="Qinit">The user's fill-reducing initial column pre-ordering.</param>
            <param name="Symbolic"></param>
            <param name="Control"></param>
            <param name="Info"></param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_save_numeric(System.IntPtr,System.String)">
            <summary>
            Saves a Numeric object to a file, which can later be read by
            umfpack_*_load_numeric.  The Numeric object is not modified.
            </summary>
            <param name="Numeric">Numeric must point to a valid Numeric object</param>
            <param name="filename">A string that contains the filename to which the Numeric object is written.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_save_symbolic(System.IntPtr,System.String)">
            <summary>
            Saves a Symbolic object to a file, which can later be read by
            umfpack_*_load_symbolic.  The Symbolic object is not modified.
            </summary>
            <param name="Symbolic">Symbolic must point to a valid Symbolic object.</param>
            <param name="filename">A string that contains the filename to which the Symbolic object is written.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_scale(System.Double[],System.Double[],System.Double[],System.Double[],System.IntPtr)">
            <summary>
            Given LU factors computed by umfpack_*_numeric (PAQ=LU, PRAQ=LU, or
            P(R\A)Q=LU), and a vector B, this routine computes X = B, X = R*B, or
            X = R\B, as appropriate.  X and B must be vectors equal in length to the
            number of rows of A.
            </summary>
            <param name="Xx">The output vector X [n_row].</param>
            <param name="Xz"></param>
            <param name="Bx">The input vector B [n_row].</param>
            <param name="Bz"></param>
            <param name="Numeric">Numeric must point to a valid Numeric object.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_solve(System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.IntPtr,System.Double[],System.Double[])">
            <summary>
            Given LU factors computed by umfpack_*_numeric (PAQ=LU, PRAQ=LU, or
            P(R\A)Q=LU) and the right-hand-side, B, solve a linear system for the
            solution X.  Iterative refinement is optionally performed.
            </summary>
            <param name="sys">Defines which system to solve.</param>
            <param name="Ap">Ap [n+1]</param>
            <param name="Ai">Ai [nz]</param>
            <param name="Ax">Ax [nz]</param>
            <param name="Az"></param>
            <param name="Xx">X [n] The solution to the linear system, where n = n_row = n_col is the dimension of the matrices A, L, and U.</param>
            <param name="Xz"></param>
            <param name="Bx">B [n] The right-hand side vector.</param>
            <param name="Bz"></param>
            <param name="Numeric">Numeric must point to a valid Numeric object</param>
            <param name="Control"></param>
            <param name="Info"></param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_symbolic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.IntPtr@,System.Double[],System.Double[])">
            <summary>
            Given nonzero pattern of a sparse matrix A in column-oriented form,
            umfpack_*_symbolic performs a column pre-ordering to reduce fill-in
            (using COLAMD, AMD or METIS) and a symbolic factorization.
            </summary>
            <param name="n_row">A is an n_row-by-n_col matrix.</param>
            <param name="n_col">A is an n_row-by-n_col matrix.</param>
            <param name="Ap">Ap is an integer array of size n_col+1.</param>
            <param name="Ai">The row indices Ai [nz].</param>
            <param name="Ax">The numerical values Ax [nz].</param>
            <param name="Az"></param>
            <param name="Symbolic">On output, this variable holds a pointer to the Symbolic
            object (if successful), or NULL if a failure occurred.</param>
            <param name="Control"></param>
            <param name="Info"></param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_transpose(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32)">
            <summary>
            Transposes and optionally permutes a sparse matrix in row or column-form, R = (PAQ)'.
            </summary>
            <param name="n_row">A is an n_row-by-n_col matrix.</param>
            <param name="n_col">A is an n_row-by-n_col matrix.</param>
            <param name="Ap">Ap [n_col+1] The column pointers of the column-oriented form of the matrix A.</param>
            <param name="Ai">The row indices Ai [nz].</param>
            <param name="Ax">If present, these are the numerical values of the sparse matrix A.</param>
            <param name="Az"></param>
            <param name="P">The row permutation vector P [n_row] (optional).</param>
            <param name="Q">The column permutation vector Q [n_col] (optional).</param>
            <param name="Rp">The column pointers of the matrix R.</param>
            <param name="Ri">The row indices of the matrix R.</param>
            <param name="Rx">If present, these are the numerical values of the sparse matrix R.</param>
            <param name="Rz"></param>
            <param name="do_conjugate">If true, and if Ax and Rx are present, then the
            linear algebraic transpose is computed (complex conjugate).  If false, the
            array transpose is computed instead.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_triplet_to_col(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double[],System.Int32[])">
            <summary>
            Converts a sparse matrix from "triplet" form to compressed-column form.
            </summary>
            <param name="n_row">A is an n_row-by-n_col matrix.</param>
            <param name="n_col">A is an n_row-by-n_col matrix.</param>
            <param name="nz">The number of entries in the triplet form of the matrix.</param>
            <param name="Ti">The row indices of the "triplet" form of a sparse matrix.</param>
            <param name="Tj">The column indices of the "triplet" form of a sparse matrix.</param>
            <param name="Tx">The values of the "triplet" form of a sparse matrix.</param>
            <param name="Tz"></param>
            <param name="Ap">Array of size n_col+1. On output, Ap holds the "pointers" for
            the column form of the sparse matrix A.</param>
            <param name="Ai">Array of size nz. Note that only the first Ap [n_col] entries are used.</param>
            <param name="Ax">Array of size nz. Note that only the first Ap [n_col] entries are used (optional).</param>
            <param name="Az"></param>
            <param name="Map">Array of size nz. If present, then on output it holds the position of the triplets in the column-form matrix.</param>
            <returns>UMFPACK status code.</returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.NativeMethods.umfpack_zi_wsolve(System.Int32,System.Int32[],System.Int32[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.IntPtr,System.Double[],System.Double[],System.Int32[],System.Double[])">
            <summary>
            Given LU factors computed by umfpack_*_numeric (PAQ=LU) and the
            right-hand-side, B, solve a linear system for the solution X.  Iterative
            refinement is optionally performed.
            </summary>
            <param name="sys"></param>
            <param name="Ap"></param>
            <param name="Ai"></param>
            <param name="Ax"></param>
            <param name="Az"></param>
            <param name="Xx"></param>
            <param name="Xz"></param>
            <param name="Bx"></param>
            <param name="Bz"></param>
            <param name="Numeric"></param>
            <param name="Control"></param>
            <param name="Info"></param>
            <param name="Wi"></param>
            <param name="W"></param>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackContext`1">
            <summary>
            UMFPACK context wrapping native factorization.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackContext`1.Info">
            <summary>
            Gets the UMFPACK info.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackContext`1.Control">
            <summary>
            Gets the UMFPACK control.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.#ctor(CSparse.Storage.CompressedColumnStorage{`0})">
            <summary>
            Initializes a new instance of the UmfpackContext class.
            </summary>
            <param name="matrix">The sparse matrix to factorize.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.Factorize">
            <summary>
            Factorizes the matrix associated to this UMFPACK instance.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.Solve(`0[],`0[])">
            <summary>
            Solves a system of linear equations, Ax = b.
            </summary>
            <param name="input">Right hand side vector b.</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.SolveTranspose(`0[],`0[])">
            <summary>
            Solves the transpose system of linear equations, A'x = b.
            </summary>
            <param name="input">Right hand side vector b</param>
            <param name="result">Solution vector x.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.Solve(CSparse.Storage.DenseColumnMajorStorage{`0},CSparse.Storage.DenseColumnMajorStorage{`0})">
            <summary>
            Solves a system of linear equations for multiple right-hand sides, AX = B.
            </summary>
            <param name="input">Right hand side matrix B.</param>
            <param name="result">Solution matrix X.</param>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.DoInitialize">
            <summary>
            Do initialization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.DoSymbolic">
            <summary>
            Do symbolic factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.DoNumeric">
            <summary>
            Do numeric factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.DoFactorize">
            <summary>
            Do symbolic and numeric factorization for current type.
            </summary>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.DoSolve(CSparse.Interop.Umfpack.UmfpackSolve,`0[],`0[])">
            <summary>
            Solve system of linear equations.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right-hand side b.</param>
            <param name="result">The solution x.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.DoSolve(CSparse.Interop.Umfpack.UmfpackSolve,`0[],`0[],System.Int32[],System.Double[])">
            <summary>
            Solve system of linear equations using given workspace.
            </summary>
            <param name="sys">The system to solve.</param>
            <param name="input">Right-hand side b.</param>
            <param name="result">The solution x.</param>
            <param name="wi">Integer workspace.</param>
            <param name="wx">Double workspace.</param>
            <returns></returns>
        </member>
        <member name="M:CSparse.Interop.Umfpack.UmfpackContext`1.CreateWorkspace(System.Int32,System.Boolean)">
            <summary>
            Create workspace for solving multiple right-hand sides.
            </summary>
            <param name="n">Size of the linear system.</param>
            <param name="refine">Perform iterative refinement.</param>
            <returns></returns>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackStrategy">
            <summary>
            Factorization strategy (auto, symmetric, or unsymmetric).
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackStrategy.Auto">
            <summary>
            Use symmetric or unsymmetric strategy.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackStrategy.Unsymmetric">
            <summary>
            COLAMD(A), coletree postorder, not prefer diagonal.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackStrategy.Symmetric">
            <summary>
            AMD(A+A'), no coletree postorder, prefer diagonal.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackScale">
            <summary>
            Row scaling.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackScale.None">
            <summary>
            No scaling.
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackScale.Sum">
            <summary>
            Default: divide each row by sum (abs(row)).
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackScale.Max">
            <summary>
            Divide each row by max (abs(row)).
            </summary>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackOrdering">
            <summary>
            Ordering method to use.
            </summary>
            <remarks>
            AMD/COLAMD means: use AMD for symmetric strategy, COLAMD for unsymmetric.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackOrdering.CHOLMOD">
            <summary>
            Use CHOLMOD (AMD/COLAMD then METIS)
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackOrdering.AMD">
            <summary>
            Use AMD/COLAMD
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackOrdering.Given">
            <summary>
            User-provided Qinit
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackOrdering.METIS">
            <summary>
            Use METIS
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackOrdering.Best">
            <summary>
            Try many orderings, pick best
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackOrdering.None">
            <summary>
            Natural ordering
            </summary>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackControl">
            <summary>
            UMFPACK control.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.PrintLevel">
            <summary>
            Gets or sets the print level.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.DenseRow">
            <summary>
            Gets or sets the dense row parameter for COLAMD.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.DenseColumn">
            <summary>
            Gets or sets the dense column parameter for COLAMD.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.BlockSize">
            <summary>
            Gets or sets the BLAS-3 block size.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.Strategy">
            <summary>
            Gets or sets the factorization strategy.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.Ordering">
            <summary>
            Gets or sets the ordering method to use.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.FixQ">
            <summary>
            Gets or sets a value indicating whether the pre-ordering Q may be modified during factorization (-1: no fixQ, 0: default, 1: fixQ).
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.AMD_Dense">
            <summary>
            Gets or sets the dense row/column threshold for AMD ordering.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.Aggressive">
            <summary>
            Gets or sets a value indicating whether aggressive absorption is used in COLAMD and AMD.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.Singletons">
            <summary>
            Gets or sets a value indicating whether singletons are removed prior to factorization.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.PivotTolerance">
            <summary>
            Gets or sets the partial pivoting tolerance.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.AllocInit">
            <summary>
            Gets or sets the initial allocation ratio.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.SymPivotTolerance">
            <summary>
            Gets or sets the threshold, if diagonal pivoting is attempted (symmetric strategy).
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.Scale">
            <summary>
            Gets or sets the row scaling strategy.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.FrontAllocInit">
            <summary>
            Gets or sets the frontal matrix allocation ratio.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.DropTolerance">
            <summary>
            Gets or sets the drop tolerance for entries in L and U.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackControl.IterativeRefinement">
            <summary>
            Gets or sets the maximum number of iterative refinements.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackException">
            <summary>
            UMFPACK exception.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackException.ErrorCode">
            <summary>
            Zero means success, negative means a fatal error, positive is a warning.
            </summary>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackInfo">
            <summary>
            UMFPACK info.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.PrintLevel">
            <summary>
            Gets or sets the print level
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.STATUS">
            <summary>
            Status code. This is also the return value, whether or not Info is present.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NROW">
            <summary>
            The value of the input argument n_row.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NCOL">
            <summary>
            The value of the input argument n_col.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NZ">
            <summary>
            # of entries in A
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SIZE_OF_UNIT">
            <summary>
            sizeof (Unit)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SIZE_OF_INT">
            <summary>
            sizeof (int)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SIZE_OF_LONG">
            <summary>
            sizeof (SuiteSparse_long)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SIZE_OF_POINTER">
            <summary>
            sizeof (void *)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SIZE_OF_ENTRY">
            <summary>
            sizeof (Entry), real or complex
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NDENSE_ROW">
            <summary>
            number of dense rows
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NEMPTY_ROW">
            <summary>
            number of empty rows
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NDENSE_COL">
            <summary>
            number of dense rows
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NEMPTY_COL">
            <summary>
            number of empty rows
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMBOLIC_DEFRAG">
            <summary>
            # of memory compactions
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMBOLIC_PEAK_MEMORY">
            <summary>
            memory used by symbolic analysis
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMBOLIC_SIZE">
            <summary>
            size of Symbolic object, in Units
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMBOLIC_TIME">
            <summary>
            time (sec.) for symbolic analysis
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMBOLIC_WALLTIME">
            <summary>
            wall clock time for sym. analysis
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.STRATEGY_USED">
            <summary>
            strategy used: sym, unsym
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.ORDERING_USED">
            <summary>
            ordering used: colamd, amd, given
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.QFIXED">
            <summary>
            whether Q is fixed or refined
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.DIAG_PREFERRED">
            <summary>
            whether diagonal pivoting attempted
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.PATTERN_SYMMETRY">
            <summary>
            symmetry of pattern of S
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NZ_A_PLUS_AT">
            <summary>
            nnz (S+S'), excl. diagonal
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NZDIAG">
            <summary>
            nnz (diag (S))
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMMETRIC_LUNZ">
            <summary>
            nz in L+U, if AMD ordering used
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMMETRIC_FLOPS">
            <summary>
            flops for LU, if AMD ordering used
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMMETRIC_NDENSE">
            <summary>
            # of "dense" rows/cols in S+S'
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SYMMETRIC_DMAX">
            <summary>
            max nz in cols of L, for AMD
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.COL_SINGLETONS">
            <summary>
            # of column singletons
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.ROW_SINGLETONS">
            <summary>
            # of row singletons
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.N2">
            <summary>
            size of S
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.S_SYMMETRIC">
            <summary>
            1 if S square and symmetricly perm.
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_SIZE_ESTIMATE">
            <summary>
            final size of Numeric->Memory
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:CSparse.Interop.Umfpack.UmfpackInfo.PEAK_MEMORY_ESTIMATE" -->
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.FLOPS_ESTIMATE">
            <summary>
            flop count
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.LNZ_ESTIMATE">
            <summary>
            nz in L, incl. diagonal
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.UNZ_ESTIMATE">
            <summary>
            nz in U, incl. diagonal
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.VARIABLE_INIT_ESTIMATE">
            <summary>
            initial size of Numeric->Memory
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.VARIABLE_PEAK_ESTIMATE">
            <summary>
            peak size of Numeric->Memory
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.VARIABLE_FINAL_ESTIMATE">
            <summary>
            final size of Numeric->Memory
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.MAX_FRONT_SIZE_ESTIMATE">
            <summary>
            max frontal matrix size
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.MAX_FRONT_NROWS_ESTIMATE">
            <summary>
            max # rows in any front
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.MAX_FRONT_NCOLS_ESTIMATE">
            <summary>
            max # columns in any front
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_SIZE">
            <summary>
            final size of Numeric->Memory
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:CSparse.Interop.Umfpack.UmfpackInfo.PEAK_MEMORY" -->
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.FLOPS">
            <summary>
            flop count
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.LNZ">
            <summary>
            nz in L, incl. diagonal
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.UNZ">
            <summary>
            nz in U, incl. diagonal
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.VARIABLE_INIT">
            <summary>
            initial size of Numeric->Memory
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.VARIABLE_PEAK">
            <summary>
            peak size of Numeric->Memory
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.VARIABLE_FINAL">
            <summary>
            final size of Numeric->Memory
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.MAX_FRONT_SIZE">
            <summary>
            max frontal matrix size
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.MAX_FRONT_NROWS">
            <summary>
            max # rows in any front
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.MAX_FRONT_NCOLS">
            <summary>
            max # columns in any front
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_DEFRAG">
            <summary>
            # of garbage collections
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_REALLOC">
            <summary>
            # of memory reallocations
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_COSTLY_REALLOC">
            <summary>
            # of costlly memory realloc's
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.COMPRESSED_PATTERN">
            <summary>
            # of integers in LU pattern
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.LU_ENTRIES">
            <summary>
            # of reals in LU factors
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_TIME">
            <summary>
            numeric factorization time
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.UDIAG_NZ">
            <summary>
            nz on diagonal of U
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.RCOND">
            <summary>
            est. reciprocal condition #
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.WAS_SCALED">
            <summary>
            none, max row, or sum row
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.RSMIN">
            <summary>
            min (max row) or min (sum row)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.RSMAX">
            <summary>
            max (max row) or max (sum row)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.UMIN">
            <summary>
            min abs diagonal entry of U
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.UMAX">
            <summary>
            max abs diagonal entry of U
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.ALLOC_INIT_USED">
            <summary>
            alloc_init parameter used
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.FORCED_UPDATES">
            <summary>
            # of forced updates
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NUMERIC_WALLTIME">
            <summary>
            numeric wall clock time
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NOFF_DIAG">
            <summary>
            number of off-diagonal pivots
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.ALL_LNZ">
            <summary>
            nz in L, if no dropped entries
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.ALL_UNZ">
            <summary>
            nz in U, if no dropped entries
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.NZDROPPED">
            <summary>
            # of dropped small entries
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.IR_TAKEN">
            <summary>
            # of iterative refinement steps taken
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.IR_ATTEMPTED">
            <summary>
            # of iter. refinement steps attempted
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.OMEGA1">
            <summary>
            omega1, sparse backward error estimate
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.OMEGA2">
            <summary>
            omega2, sparse backward error estimate
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SOLVE_FLOPS">
            <summary>
            flop count for solve
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SOLVE_TIME">
            <summary>
            solve time (seconds)
            </summary>
        </member>
        <member name="P:CSparse.Interop.Umfpack.UmfpackInfo.SOLVE_WALLTIME">
            <summary>
            solve time (wall clock, seconds)
            </summary>
        </member>
        <member name="T:CSparse.Interop.Umfpack.UmfpackSolve">
            <summary>
            Umfpack solve codes.
            </summary>
            <remarks>
            Solve the system ( )x=b, where ( ) is defined below.  "t" refers to the
            linear algebraic transpose (complex conjugate if A is complex), or the (')
            operator in MATLAB.  "at" refers to the array transpose, or the (.')
            operator in MATLAB.
            </remarks>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.A">
            <summary>
            Ax=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.At">
            <summary>
            A'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Aat">
            <summary>
            A.'x=b 
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Pt_L">
            <summary>
            P'Lx=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.L">
            <summary>
            Lx=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Lt_P">
            <summary>
            L'Px=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Lat_P">
            <summary>
            L.'Px=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Lt">
            <summary>
            L'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Lat">
            <summary>
            L.'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.U_Qt">
            <summary>
            UQ'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.U">
            <summary>
            Ux=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Q_Ut">
            <summary>
            QU'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Q_Uat">
            <summary>
            QU.'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Ut">
            <summary>
            U'x=b
            </summary>
        </member>
        <member name="F:CSparse.Interop.Umfpack.UmfpackSolve.Uat">
            <summary>
            U.'x=b
            </summary>
        </member>
        <member name="T:CSparse.Solvers.IEigenSolver`1">
            <summary>
            Interface for eigensolvers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolver`1.SolveStandard(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>Retruns an <see cref="T:CSparse.Solvers.IEigenSolverResult"/>.</returns>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolver`1.SolveStandard(System.Int32,`0,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the standard eigenvalue problem in shift-invert mode.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="sigma">The shift value.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>Retruns an <see cref="T:CSparse.Solvers.IEigenSolverResult"/>.</returns>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolver`1.SolveGeneralized(System.Int32,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>Retruns an <see cref="T:CSparse.Solvers.IEigenSolverResult"/>.</returns>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolver`1.SolveGeneralized(System.Int32,`0,CSparse.Solvers.Spectrum)">
            <summary>
            Solve the generalized eigenvalue problem in shift-invert mode.
            </summary>
            <param name="k">The number of eigenvalues to compute.</param>
            <param name="sigma">The shift value.</param>
            <param name="job">The part of the spectrum to compute.</param>
            <returns>Retruns an <see cref="T:CSparse.Solvers.IEigenSolverResult"/>.</returns>
        </member>
        <member name="T:CSparse.Solvers.IEigenSolverResult">
            <summary>
            Interface for result returned by an <see cref="T:CSparse.Solvers.IEigenSolver`1"/>.
            </summary>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.Count">
            <summary>
            Gets the number of requested eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.ConvergedEigenValues">
            <summary>
            Gets the number of converged eigenvalues.
            </summary>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.IterationsTaken">
            <summary>
            Gets the number of iteration taken.
            </summary>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.ArnoldiCount">
            <summary>
            Gets the number of Arnoldi vectors computed.
            </summary>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.ErrorCode">
            <summary>
            Gets the error code returned by the solver.
            </summary>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolverResult.EnsureSuccess">
            <summary>
            Throws an exception, if the eigensolver failed to solve the problem.
            </summary>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.EigenVectors">
            <summary>
            Gets the dense matrix of eigenvectors stored in column major order.
            </summary>
            <remarks>
            For real symmetric matrices, eigenvectors will be real. Use <see cref="M:CSparse.Solvers.IEigenSolverResult.EigenVectorsReal"/>.
            </remarks>
        </member>
        <member name="P:CSparse.Solvers.IEigenSolverResult.EigenValues">
            <summary>
            Gets the eigenvalues.
            </summary>
            <remarks>
            For real symmetric matrices, eigenvalues will be real. Use <see cref="M:CSparse.Solvers.IEigenSolverResult.EigenValuesReal"/>.
            </remarks>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolverResult.EigenValuesReal">
            <summary>
            Gets the real part of the eigenvalues.
            </summary>
        </member>
        <member name="M:CSparse.Solvers.IEigenSolverResult.EigenVectorsReal">
            <summary>
            Gets the real part of the eigenvectors.
            </summary>
        </member>
        <member name="T:CSparse.Solvers.Spectrum">
            <summary>
            Selection rule for the spectrum to compute.
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.LargestAlgebraic">
            <summary>
            Largest algebraic (ARPACK which "LA").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.LargestMagnitude">
            <summary>
            Largest magnitude (ARPACK which "LM").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.LargestRealPart">
            <summary>
            Largest real part (ARPACK which "LR").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.LargestImaginaryPart">
            <summary>
            Largest imaginary part (ARPACK which "LI").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.SmallestAlgebraic">
            <summary>
            Smallest algebraic (ARPACK which "SA").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.SmallestMagnitude">
            <summary>
            Smallest magnitude (ARPACK which "SM").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.SmallestRealPart">
            <summary>
            Smallest real part (ARPACK which "SR").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.SmallestImaginaryPart">
            <summary>
            Smallest imaginary part (ARPACK which "SI").
            </summary>
        </member>
        <member name="F:CSparse.Solvers.Spectrum.BothEnds">
            <summary>
            Both ends of the spectrum (ARPACK which "BE").
            </summary>
        </member>
    </members>
</doc>
